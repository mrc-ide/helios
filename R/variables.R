#' Generate a list of the model variables
#'
#' @param parameters_list A list of model parameters as generated by `get_parameters`
#'
#' @export
create_variables <- function(parameters_list) {

  # Initialise and populate the disease state variable:
  disease_states <- c("S", "E", "I", "R")
  initial_disease_states <- generate_initial_disease_states(parameters_list = parameters_list)
  disease_state_variable <- individual::CategoricalVariable$new(categories = disease_states,
                                                                initial_values = initial_disease_states)

  # If user wants to use empirical distribution of households from ONS - this generates
  # both the household variable AND the age class variable
  if (parameters_list$household_distribution_generation == "empirical") {

    # Bootstrap sampling of households from ONS 2011 Census reference panel of household sizes and age composition
    household_age_list <- generate_initial_households_boostrap(parameters_list = parameters_list)

    # Initialise and populate the age class variable:
    age_classes <- c("child", "adult", "elderly")
    age_class_variable <- individual::CategoricalVariable$new(categories = age_classes,
                                                              initial_values = household_age_list$age_class_vector)

    # Initialise and populate the household variable
    household_variable <- individual::CategoricalVariable$new(categories = as.character(1:max(household_age_list$individual_households)),
                                                              initial_values = as.character(household_age_list$individual_households))

    ## If user wants to specify age-class proportions manually
  } else {

    # Initialise and populate the age class variable:
    age_classes <- c("child", "adult", "elderly")
    initial_age_classes <- generate_initial_age_classes(parameters_list = parameters_list)
    age_class_variable <- individual::CategoricalVariable$new(categories = age_classes,
                                                              initial_values = initial_age_classes)

    # Initialise and populate the household variable
    initial_households <- generate_initial_households(parameters_list = parameters_list, age_class_variable = age_class_variable)
    household_variable <- CategoricalVariable$new(categories = as.character(1:max(initial_households)),
                                                  initial_values = as.character(initial_households))
  }

  # Initialise and populate the workplace setting variable:
  initial_workplace_settings <- generate_initial_workplaces(parameters_list = parameters_list, age_class_variable = age_class_variable)
  num_workplaces <- max(as.numeric(initial_workplace_settings))
  workplace_variable <- CategoricalVariable$new(categories = as.character(0:num_workplaces),
                                                initial_values = initial_workplace_settings)

  # Initialise and populate the school setting variable:
  initial_school_settings <- generate_initial_schools(parameters_list = parameters_list, age_class_variable = age_class_variable)
  num_schools <- max(as.numeric(initial_school_settings))
  school_variable <- CategoricalVariable$new(categories = as.character(0:num_schools),
                                             initial_values = initial_school_settings)

  # Initialise and populate the leisure setting variable that stores all the leisure locations individual COULD go to
  # Generating the number and sizes of each leisure setting
  leisure_setting_sizes <- sample_negbinom(N = parameters_list$human_population,
                                           prop_max = parameters_list$leisure_prop_max,
                                           mu = parameters_list$leisure_mean_size,
                                           size = parameters_list$leisure_overdispersion_size)
  initial_leisure_settings <- generate_initial_leisure(parameters_list = parameters_list, leisure_setting_sizes = leisure_setting_sizes) # returns list to initialise RaggedInteger
  leisure_variable <- RaggedInteger$new(initial_values = initial_leisure_settings)

  # Initialise and populate the leisure setting variable for where individuals go to on a particular day
  possible_leisure_settings <- unique(unlist(initial_leisure_settings))
  possible_leisure_settings <- possible_leisure_settings[order(possible_leisure_settings)]
  specific_day_leisure_variable <- CategoricalVariable$new(categories = as.character(possible_leisure_settings),
                                                           initial_values = rep(as.character(0), parameters_list$human_population))

  # Store the model variables in a single list:
  variables_list <- list(
    disease_state = disease_state_variable,
    age_class = age_class_variable,
    workplace = workplace_variable,
    school = school_variable,
    household = household_variable,
    leisure = leisure_variable,
    specific_leisure = specific_day_leisure_variable
  )

  # If any setting has UVC parameterised, retrieve the setting sizes:
  # Decide whether we want to do this step regardless of UVC and append sizes to variables_list
  if(any(parameters_list$far_uvc_workplace,
         parameters_list$far_uvc_school,
         parameters_list$far_uvc_leisure,
         parameters_list$far_uvc_household)) {

    # Store setting sizes in a list:
    setting_sizes <- get_setting_sizes(variables_list = variables_list,
                                             leisure_sizes = leisure_setting_sizes)

    # Append setting sizes to variables_list:
    variables_list$setting_sizes <- setting_sizes
  }

  # Parameterise Far UVC in the workplace setting:
  if(parameters_list$far_uvc_workplace) {

    # Get the number of workplaces:
    number_of_workplaces <- length(variables_list$workplace$get_categories())

    # Open a vector to store the workplace UVC on/off values:
    uvc_workplace <- rep(0, number_of_workplaces)

    # Calculate the number of workplaces that will have Far UVC:
    number_of_workplaces_with_uvc <- floor(parameters_list$far_uvc_workplace_coverage * number_of_workplaces)

    # If coverage type is random, assign workplaces at random:
    if(parameters_list$far_uvc_workplace_coverage_type == "random") {

      # Sample the indices of workplaces to have Far UVC at random:
      indices_of_workplaces_with_uvc <- sample.int(n = number_of_workplaces,
                                                   size = number_of_workplaces_with_uvc,
                                                   replace = FALSE)

      # Insert 1's at the indices of workplaces selected to have Far-UVC:
      uvc_workplace[indices_of_workplaces_with_uvc] <- 1

      # Append the vector of workplace UVC on/off values to the variables_list:
      variables_list$uvc_workplace <- uvc_workplace
    }

    # If coverage type is targeted, assign UVC to the most populous workplaces:
    if(parameters_list$far_uvc_workplace_coverage_type == "targeted") {

      # Get the indices of the indices of workplaces with Far UVC based on their sizes:
      indices_of_workplaces_with_uvc <- sort(x = variables_list$setting_sizes$workplace,
                                             decreasing = T,
                                             index.return = TRUE)$ix[1:number_of_workplaces_with_uvc]

      # Insert 1's at the indices of workplaces selected to have Far-UVC:
      uvc_workplace[indices_of_workplaces_with_uvc] <- 1

      # Append the vector of workplace UVC on/off values to the variables_list:
      variables_list$uvc_workplace <- uvc_workplace

    }
  }

  # Parameterise Far UVC in the school setting:
  if(parameters_list$far_uvc_school) {

    # Get the number of schools:
    number_of_schools <- length(variables_list$school$get_categories())

    # Open a vector to store the school UVC on/off values:
    uvc_school <- rep(0, number_of_schools)

    # Calculate the number of schools that will have Far UVC:
    number_of_schools_with_uvc <- floor(parameters_list$far_uvc_school_coverage * number_of_schools)

    if(coverage_type == "random") {

      # Sample the indices of schools to have Far UVC at random:
      indices_of_schools_with_uvc <- sample.int(n = number_of_schools,
                                                   size = number_of_schools_with_uvc,
                                                   replace = FALSE)

      # Insert 1's at the indices of schools selected to have Far-UVC:
      uvc_school[indices_of_schools_with_uvc] <- 1

      # Append the vector of school UVC on/off values to the variables_list:
      variables_list$uvc_school <- uvc_school

    }

    if(coverage_type == "targeted") {

      # Get the indices of the indices of schools with Far UVC based on their sizes:
      indices_of_schools_with_uvc <- sort(x = variables_list$setting_sizes$school,
                                             decreasing = T,
                                             index.return = TRUE)$ix[1:number_of_workplaces_with_uvc]

      # Insert 1's at the indices of workplaces selected to have Far-UVC:
      uvc_school[indices_of_schools_with_uvc] <- 1

      # Append the vector of workplace UVC on/off values to the variables_list:
      variables_list$uvc_school <- uvc_school

    }
  }

  # Parameterise Far UVC in the leisure setting:
  if(parameters_list$far_uvc_leisure) {
    if(coverage_type == "random") {
    }
    if(coverage_type == "targeted") {
    }
  }
  #
  # # Parameterise Far UVC in the household setting:
  # if(parameters_list$far_uvc_household) {
  #   if(coverage_type == "random") {
  #   }
  #   if(coverage_type == "targeted") {
  #   }
  # }

  # Return the list of model variables:
  return(variables_list)

}

#' Generate a vector of the initial disease states of all individuals in the population
#'
#' @param parameters_list A list of model parameters as generated by `get_parameters`
#'
#' @export
generate_initial_disease_states <- function(parameters_list) {

  # Checking that the parameters contain the initial human population size, proportion
  # initially exposed, and a seed:
  if (!("number_initially_exposed" %in% names(parameters_list))) {
    stop("parameters list must contain a variable called number_initially_exposed")
  }
  if (!("human_population" %in% names(parameters_list))) {
    stop("parameters list must contain a variable called human_population")
  }
  if (!("seed" %in% names(parameters_list))) {
    stop("parameters list must contain a variable called seed")
  }

  # Set the seed from the parameter list:
  set.seed(parameters_list$seed)

  # Create a vector of disease states of length human_population:
  initial_disease_states <- rep("S", parameters_list$human_population)

  # Sample indices between 1:human population to set an initially exposed:
  infection_index <- sample(x = 1:length(initial_disease_states),
                            size = parameters_list$number_initially_exposed,
                            replace = FALSE,
                            prob = NULL)

  # Replace the disease state at the sampled indices with to "E" (Exposed)
  initial_disease_states[infection_index] <- "E"

  # Return the vector of initial disease states:
  return(initial_disease_states)

}

#' Generates a vector of the age classes of all individuals in the population
#'
#' @param parameters_list A list of model parameters as generated by `get_parameters`
#'
#' @export
generate_initial_age_classes <- function(parameters_list) {

  # Check the parameters required are present in the parameters list:
  if (!("initial_proportion_child" %in% names(parameters_list))) {
    stop("parameters list must contain a variable called initial_proportion_child")
  }
  if (!("initial_proportion_adult" %in% names(parameters_list))) {
    stop("parameters list must contain a variable called initial_proportion_adult")
  }
  if (!("initial_proportion_elderly" %in% names(parameters_list))) {
    stop("parameters list must contain a variable called initial_proportion_elderly")
  }
  if (!("human_population" %in% names(parameters_list))) {
    stop("parameters list must contain a variable called human_population")
  }
  if (!("seed" %in% names(parameters_list))) {
    stop("parameters list must contain a variable called seed")
  }

  # Check the initial age class proportions sum to 1:
  if (sum(parameters_list$initial_proportion_child, parameters_list$initial_proportion_adult, parameters_list$initial_proportion_elderly) != 1) {
    stop("initial age class proportions do not sum to 1")
  }

  # Set the seed stored in the parameter list:
  set.seed(parameters_list$seed)

  # Store age group proportions in a single vector:
  age_group_proportions <- c(parameters_list$initial_proportion_child,
                             parameters_list$initial_proportion_adult,
                             parameters_list$initial_proportion_elderly)

  # Use the initial age class proportions to sample and create a vector of initial age classes:
  age_classes <- sample(c("child", "adult", "elderly"),
                        size = parameters_list$human_population,
                        replace = TRUE,
                        prob = age_group_proportions)

  # Return the vector of initial age classes:
  return(age_classes)

}

#' Gets workplace assignments for all individuals in the population
#'
#' @param parameters_list A list of model parameters as generated by `get_parameters`
#' @param age_class_variable An `individual::CategoricalVariable` for the age classes
#'
#' @export
generate_initial_workplaces <- function(parameters_list, age_class_variable) {

  # Checking that the parameter list contains the requisite parameters
  if (!("human_population" %in% names(parameters_list))) {
    stop("parameters list must contain a variable called human_population")
  }
  if (!("seed" %in% names(parameters_list))) {
    stop("parameters list must contain a variable called seed")
  }
  if (!("workplace_prop_max" %in% names(parameters_list))) {
    stop("parameters list must contain a variable called workplace_prop_max")
  }
  if (!("workplace_a" %in% names(parameters_list))) {
    stop("parameters list must contain a variable called workplace_a")
  }
  if (!("workplace_c" %in% names(parameters_list))) {
    stop("parameters list must contain a variable called workplace_c")
  }

  # Calculating number of adults and assigning them to workplaces
  set.seed(parameters_list$seed)
  num_adults <- age_class_variable$get_size_of("adult") # get number of adults
  index_adults <- age_class_variable$get_index_of("adult")$to_vector() # get the index of adults in age_class_variable
  workplace_sizes <- sample_offset_truncated_power_distribution(N = num_adults,
                                                                prop_max = parameters_list$workplace_prop_max,
                                                                a = parameters_list$workplace_a,
                                                                c = parameters_list$workplace_c)
  workplace_indices <- unlist(sapply(1:length(workplace_sizes), function(i) rep(as.character(i), workplace_sizes[i])))
  adult_workplace_assignments <- sample(workplace_indices, replace = FALSE)

  # Creating a vector containing workplace assignments for all individuals (i.e. adult_workplace_assignments for adults,
  # 0 for children and elderly)
  workplace_vector <- vector(mode = "character", length = parameters_list$human_population) # create an empty vector to be filled with workplace assignments
  workplace_vector[index_adults] <- adult_workplace_assignments # append workplace assignments to main workplaces vector
  workplace_vector[workplace_vector == ""] <- "0" # replace blanks with 0s (these are children/elderly people)

  return(workplace_vector)
}

#' Gets school assignments for all individuals
#'
#' @param parameters_list A list of model parameters as generated by `get_parameters`
#' @param age_class_variable An `individual::CategoricalVariable` for the age classes
#'
#' @export
generate_initial_schools <- function(parameters_list, age_class_variable) {

  # Check that the requisite parameters are present:
  if (!("human_population" %in% names(parameters_list))) {
    stop("parameters list must contain a variable called human_population")
  }
  if (!("seed" %in% names(parameters_list))) {
    stop("parameters list must contain a variable called seed")
  }
  if (!("school_meanlog" %in% names(parameters_list))) {
    stop("parameters list must contain a variable called school_meanlog")
  }
  if (!("school_sdlog" %in% names(parameters_list))) {
    stop("parameters list must contain a variable called school_sdlog")
  }

  # Calculating number of children and assigning them to schools
  set.seed(parameters_list$seed)
  num_children <- age_class_variable$get_size_of("child") # get number of children
  index_children <- age_class_variable$get_index_of("child")$to_vector() # get the index of children in age_class_variable
  school_sizes <- sample_log_normal(N = num_children,
                                    prop_max = parameters_list$school_prop_max,
                                    meanlog = parameters_list$school_meanlog,
                                    sdlog = parameters_list$school_sdlog)
  school_indices <- unlist(sapply(1:length(school_sizes), function(i) rep(as.character(i), school_sizes[i])))
  child_school_assignments <- sample(school_indices, replace = FALSE)

  # Creating a vector containing school assignments for all individuals (i.e. child_school_assignments for children,
  # 0 for adults and elderly)
  schools_vector <- vector(mode = "character", length = parameters_list$human_population) # create empty vector to be filled with school assignments
  schools_vector[index_children] <- child_school_assignments # append school assignment to main schools vector
  schools_vector[schools_vector == ""] <- "0" # replace blanks with 0s (these are adults/elderly people)

  return(schools_vector)
}

#' Generates a list of leisure settings that each individual visits, for all individuals in the population
#' Each element of this list indicates which settings each individual visits on which day - a 0 indicates
#' that the person stays in on that day.
#'
#' @param parameters_list A list of model parameters as generated by `get_parameters`
#'
#' @export
generate_initial_leisure <- function(parameters_list, leisure_setting_sizes) {

  # Check that the requisite parameters are present:
  if (!("human_population" %in% names(parameters_list))) {
    stop("parameters list must contain a variable called human_population")
  }
  if (!("seed" %in% names(parameters_list))) {
    stop("parameters list must contain a variable called seed")
  }
  if (!("leisure_mean_size" %in% names(parameters_list))) {
    stop("parameters list must contain a variable called leisure_mean_size")
  }
  if (!("leisure_overdispersion_size" %in% names(parameters_list))) {
    stop("parameters list must contain a variable called leisure_overdispersion_size")
  }
  if (!("leisure_mean_number_settings" %in% names(parameters_list))) {
    stop("parameters list must contain a variable called leisure_mean_number_settings")
  }

  # Setting the seed
  set.seed(parameters_list$seed)

  # Calculating the number of leisure visits that each person makes per week
  leisure_visits_per_person_per_week <- rpois(n = parameters_list$human_population,
                                              lambda = parameters_list$leisure_mean_number_settings)
  leisure_visits_per_person_per_week[leisure_visits_per_person_per_week > 7] <- 7  # capping it at 1 leisure visit per day (max 7 per week)

  # Populating a list with the leisure visits made by each individual
  leisure_visit_list <- vector(mode = "list", length = parameters_list$human_population)
  for (i in 1:parameters_list$human_population) {

    # Creating a temporary vector of leisure visits for that person
    # -> Each element indicates where they visit on which day of the week
    #    and a 0 means nowhere visited on that day of the week
    temp_leisure_visit <- rep(0, 7)

    # Sampling which locations individuals visit for their leisure visits (weighted according to leisure setting size)
    temp_location_leisure_visits <- sample(x = 1:length(leisure_setting_sizes),
                                           size = leisure_visits_per_person_per_week[i],
                                           replace = FALSE,
                                           prob = leisure_setting_sizes)

    # Sampling which day(s) of the week the individual makes those visit(s) and assigning visits randomly
    days_visits_made <- sample(x = 1:7, size = leisure_visits_per_person_per_week[i], replace = FALSE)
    if (leisure_visits_per_person_per_week[i] == 1) {
      temp_leisure_visit[days_visits_made] <- temp_location_leisure_visits
    } else {
      temp_leisure_visit[days_visits_made] <- sample(x = temp_location_leisure_visits,
                                                     size = leisure_visits_per_person_per_week[i],
                                                     replace = FALSE)
    }
    leisure_visit_list[[i]] <- temp_leisure_visit
  }

  return(leisure_visit_list) # a list where each element contains a vector that specifies the ids of the leisure settings
                             # that each individual visits e.g. list(c(2, 6, 19, 35), c(1, 8), c(6, 10, 45)... etc)

}

#' Generates a vector of households for all individuals in the population
#'
#' @param parameters_list A list of model parameters as generated by `get_parameters`
#' @param age_class_variable An `individual::CategoricalVariable` for the age classes
#'
#' @export
generate_initial_households <- function(parameters_list, age_class_variable) {

  # Check that the requisite parameters are present:
  if (!("human_population" %in% names(parameters_list))) {
    stop("parameters list must contain a variable called human_population")
  }
  if (!("seed" %in% names(parameters_list))) {
    stop("parameters list must contain a variable called seed")
  }
  if (!("mean_household_size" %in% names(parameters_list))) {
    stop("parameters list must contain a variable called mean_household_size")
  }

  # Setting seed
  set.seed(parameters_list$seed)

  ## Checking population size N is the same as implied by age_class_variable
  if (parameters_list$human_population != age_class_variable$get_size_of(age_class_variable$get_categories())) {
    stop("Human population and age_class_vector are different lengths")
  }

  ## Extracting out the vector of underlying values from age_class_variable
  age_class_vector <- rep("", parameters_list$human_population)
  age_class_vector[age_class_variable$get_index_of("child")$to_vector()] <- "child"
  age_class_vector[age_class_variable$get_index_of("adult")$to_vector()] <- "adult"
  age_class_vector[age_class_variable$get_index_of("elderly")$to_vector()] <- "elderly"

  ## Track which individuals are assigned
  assigned <- rep(FALSE, parameters_list$human_population)
  individual_households <- rep(NA, parameters_list$human_population)
  household_counter <- 1

  ## Looping over this whilst there still remain any unassigned individuals
  while(sum(assigned) < parameters_list$human_population) {

    # Check if only children are left unassigned - if this is the case, then we just distribute
    # them randomly across households
    unassigned_indices <- which(!assigned)
    if(all(age_class_vector[unassigned_indices] == "child")) {
      # Distribute remaining children across existing households randomly
      for(child_idx in unassigned_indices) {
        selected_household <- sample(household_counter, 1)
        assigned[child_idx] <- TRUE
        individual_households[child_idx] <- selected_household
      }
      break # Exit the main loop as all remaining unassigned individuals are children and have been assigned
    }

    # Draw household size
    household_size <- rpois(n = 1, lambda = parameters_list$mean_household_size)

    # Initialize temporary household storage
    temp_household <- c()

    ## Looping over this whilst current household isn't full
    while(length(temp_household) < household_size && sum(assigned) < parameters_list$human_population) {

      # Randomly select an unassigned individual
      candidates <- which(!assigned)
      selected <- sample(x = candidates, size = 1)

      # Ensure selected individual meets the household formation criteria (i.e. children have to have at least 1 adult in household)
      if(age_class_vector[selected] == "child") {

        ## Check whether current household has an adult - if it does, just add the child
        if(sum(age_class_vector[temp_household] == "adult") >= 1) {
          temp_household <- c(temp_household, selected)
          assigned[selected] <- TRUE
        } else { # if not, get an adult to be added to the household
          # Ensure there is at least one unassigned adult to pair with
          unassigned_adults <- which(age_class_vector == "adult" & !assigned)
          if(length(unassigned_adults) < 1) {
            # No available adults to pair with the child, break from the inner loop
            break
          }
          # Pair child with adult(s)
          num_adults_to_add <- 1
          adults_to_add <- sample(unassigned_adults, num_adults_to_add)
          temp_household <- c(temp_household, selected, adults_to_add)
          assigned[c(selected, adults_to_add)] <- TRUE
        }

      } else {
        # Add the individual to the household if there's enough space
        if((length(temp_household) + 1) <= household_size) {
          temp_household <- c(temp_household, selected)
          assigned[selected] <- TRUE
        }
      }
    }
    # Add the completed household to the list of households, if any members were added
    if(length(temp_household) > 0) {
      individual_households[temp_household] <- household_counter
      household_counter <- household_counter + 1
    }
    # print(sum(assigned))
  }

  return(individual_households = individual_households)
}

#' Generates a vector of households for all individuals in the population
#' Alternative to generate_initial_households where instead households
#' are generated through bootstrapping of reference panel from ONS 2011 data
#' (see Hinch et al for further details). Note this is different as it generates
#' both the household and age class assignments together.
#'
#' @param parameters_list A list of model parameters as generated by `get_parameters`
#' @param age_class_variable An `individual::CategoricalVariable` for the age classes
#'
#' @export
generate_initial_households_boostrap <- function(parameters_list) {

  ## Processing Hinch et al to match our age-classes
  ref_panel <- read.csv("data/Hinch_et_al_baseline_household_demographics.csv")
  ref_panel$child <- ref_panel$a_0_9 + ref_panel$a_10_19
  ref_panel$adult <- ref_panel$a_20_29 + ref_panel$a_30_39 + ref_panel$a_40_49 + ref_panel$a_50_59 + ref_panel$a_60_69
  ref_panel$elderly <- ref_panel$a_70_79 + ref_panel$a_80
  ref_panel <- ref_panel[, c("child", "adult", "elderly")]

  # Creating blank age-class vectors and household assignment vectors to populate
  age_class_vector <- rep("", parameters_list$human_population)
  individual_households <- rep(NA, parameters_list$human_population)

  ## Looping over this whilst there still remain any unassigned individuals
  counter <- 1
  household_counter <- 1
  while(counter <= parameters_list$human_population) {

    ## Sampling a random household from the reference panel
    temp_index <- sample(1:nrow(ref_panel), 1, replace = TRUE)
    random_household <- ref_panel[temp_index, ]

    ## Expanding out the random household
    household_age_individuals <- rep(x = names(random_household), times = random_household)
    for (i in 1:length(household_age_individuals)) {
      age_class_vector[counter] <- household_age_individuals[i]
      individual_households[counter] <- household_counter
      counter <- counter + 1
    }
    household_counter <- household_counter + 1
  }

  ## Checking if there are any NAs or missing age_class assignments - if there are, randomly assigning
  ## them to houses and age-groups
  if (sum(is.na(individual_households)) > 0) {
    index_unassigned <- which(is.na(individual_households))
    if(length(index_unassigned) > 3) {
      stop("too many NAs in household generation - check this")
    }
    individual_households[index] <- sample(x = 1:max(individual_households), size = length(index_unassigned), replace = TRUE)
    age_class_vector[index] <- sample(x = unique(age_class_vector), size = length(index_unassigned), replace = TRUE,
                                      prob = unname(table(age_class_vector)) / parameters_list$human_population)
  }

  ## Scrambling the order of individuals so that household members don't appear right next to each other
  ## -> This might not be needed, need to give this some thought
  scrambled_index <- sample(x = 1:parameters_list$human_population,
                            size = parameters_list$human_population,
                            replace = FALSE)

  return(list(individual_households = individual_households[scrambled_index],
              age_class_vector = age_class_vector[scrambled_index]))

}

