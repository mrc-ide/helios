#' Generate a list of the model variables
#'
#' @param parameters_list A list of model parameters as generated by `get_parameters`
#'
#' @family variables
#' @export
create_variables <- function(parameters_list) {

  # Disease state variable
  disease_states <- c("S", "E", "I", "R")
  initial_disease_states <- generate_initial_disease_states(parameters_list = parameters_list)
  disease_state_variable <- individual::CategoricalVariable$new(categories = disease_states, initial_values = initial_disease_states)

  # Initialise and populate the age and household variables

  # If user wants to use empirical distribution of households and ages from ONS (UK) or RTI synth pop (USA)
  if (parameters_list$household_distribution_country %in% c("UK", "USA")) {
    # Bootstrap sampling of households from either ONS 2011 Census reference panel of household sizes and age composition
    # or RTI synthetic population of household sizes and age composition for San Francisco
    household_age_list <- generate_initial_households_bootstrap(parameters_list = parameters_list)

    # Age class variable
    age_classes <- c("child", "adult", "elderly")
    age_class_variable <- individual::CategoricalVariable$new(categories = age_classes, initial_values = household_age_list$age_class_vector)

    # Household variable
    household_variable <- individual::CategoricalVariable$new(categories = as.character(1:max(household_age_list$individual_households)),
                                                              initial_values = as.character(household_age_list$individual_households))
  # If user wants to specify age-class proportions and associated households manually
  } else {
    # Specify age-class proportions manually

    # Age class variable:
    age_classes <- c("child", "adult", "elderly")
    initial_age_classes <- generate_initial_age_classes(parameters_list = parameters_list)
    age_class_variable <- individual::CategoricalVariable$new(categories = age_classes, initial_values = initial_age_classes)

    # Household variable
    initial_households <- generate_initial_households(parameters_list = parameters_list, age_class_variable = age_class_variable)
    household_variable <- individual::CategoricalVariable$new(categories = as.character(1:max(initial_households)),
                                                  initial_values = as.character(initial_households))
  }

  # School setting variable
  if (parameters_list$school_distribution_generation == "empirical") {
    initial_school_settings <- generate_initial_schools_bootstrap(parameters_list = parameters_list, age_class_variable = age_class_variable)
  } else {
    initial_school_settings <- generate_initial_schools(parameters_list = parameters_list, age_class_variable = age_class_variable)
  }
  num_schools <- max(as.numeric(initial_school_settings))
  if(num_schools <= 2) {
    message("There are less than or equal to 2 schools. Consider the population size may be too small!")
  }
  school_variable <- individual::CategoricalVariable$new(categories = as.character(0:num_schools), initial_values = initial_school_settings)

  # Workplace setting variable
  initial_workplace_settings <- generate_initial_workplaces(parameters_list = parameters_list, age_class_variable = age_class_variable, school_variable = school_variable)
  num_workplaces <- max(as.numeric(initial_workplace_settings))
  if(num_workplaces <= 2) {
    message("There are less than or equal to 2 workplaces. Consider the population size may be too small!")
  }
  workplace_variable <- individual::CategoricalVariable$new(categories = as.character(0:num_workplaces), initial_values = initial_workplace_settings)

  # Initialise and populate the leisure setting variable that stores all the leisure locations an individual COULD go to
  # Generating the number and sizes of each leisure setting
  leisure_setting_sizes <- sample_negbinom(N = parameters_list$human_population,
                                           prop_max = parameters_list$leisure_prop_max,
                                           mu = parameters_list$leisure_mean_size,
                                           size = parameters_list$leisure_overdispersion_size)
  parameters_list$leisure_setting_sizes <- leisure_setting_sizes
  initial_leisure_settings <- generate_initial_leisure(parameters_list = parameters_list, leisure_setting_sizes = parameters_list$leisure_setting_sizes) # returns list to initialise RaggedInteger
  leisure_variable <- individual::RaggedInteger$new(initial_values = initial_leisure_settings)

  possible_leisure_settings <- unique(unlist(initial_leisure_settings))
  possible_leisure_settings <- possible_leisure_settings[order(possible_leisure_settings)]
  specific_day_leisure_variable <- individual::CategoricalVariable$new(categories = as.character(possible_leisure_settings),
                                                           initial_values = rep(as.character(0), parameters_list$human_population))

  # Return the list of model variables
  variables_list <- list(
    disease_state = disease_state_variable,
    age_class = age_class_variable,
    workplace = workplace_variable,
    school = school_variable,
    household = household_variable,
    leisure = leisure_variable,
    specific_leisure = specific_day_leisure_variable
  )

  # Store setting sizes in a list:
  setting_sizes <- get_setting_sizes(variables_list = variables_list,
                                     leisure_sizes = leisure_setting_sizes)

  # Append setting sizes to variables_list:
  parameters_list$setting_sizes <- setting_sizes

  # If any setting has UVC installed, retrieve the sizes of all of the settings:
  if(any(parameters_list$far_uvc_workplace,
         parameters_list$far_uvc_school,
         parameters_list$far_uvc_leisure,
         parameters_list$far_uvc_household)) {

    # Generate and append the far UVC switches for settings in which it has been switched on:
    parameters_list <- generate_far_uvc_switches(parameters_list, variables_list)
  }

  # Return the list of model variables:
  return(list(variables_list = variables_list,
              parameters_list = parameters_list))

}

#' Generate a vector of the initial disease states of all individuals in the population
#'
#' @inheritParams create_variables
#'
#' @family variables
#' @export
generate_initial_disease_states <- function(parameters_list) {

  # Checking that the parameters contain the initial human population size, proportion
  # initially exposed, and a seed:
  if (!("number_initially_exposed" %in% names(parameters_list))) {
    stop("parameters list must contain a variable called number_initially_exposed")
  }
  if (!("human_population" %in% names(parameters_list))) {
    stop("parameters list must contain a variable called human_population")
  }
  if (!("seed" %in% names(parameters_list))) {
    stop("parameters list must contain a variable called seed")
  }

  # Set the seed from the parameter list:
  set.seed(parameters_list$seed)

  # Create a vector of disease states of length human_population:
  initial_disease_states <- rep("S", parameters_list$human_population)

  # Sample indices between 1:human population to set an initially exposed:
  infection_index <- sample(x = 1:length(initial_disease_states),
                            size = parameters_list$number_initially_exposed,
                            replace = FALSE,
                            prob = NULL)

  # Replace the disease state at the sampled indices with to "E" (Exposed)
  initial_disease_states[infection_index] <- "E"

  # Return the vector of initial disease states:
  return(initial_disease_states)

}

#' Generates a vector of the age classes of all individuals in the population
#'
#' @inheritParams create_variables
#'
#' @family variables
#' @export
generate_initial_age_classes <- function(parameters_list) {

  # Check the parameters required are present in the parameters list:
  if (!("initial_proportion_child" %in% names(parameters_list))) {
    stop("parameters list must contain a variable called initial_proportion_child")
  }
  if (!("initial_proportion_adult" %in% names(parameters_list))) {
    stop("parameters list must contain a variable called initial_proportion_adult")
  }
  if (!("initial_proportion_elderly" %in% names(parameters_list))) {
    stop("parameters list must contain a variable called initial_proportion_elderly")
  }
  if (!("human_population" %in% names(parameters_list))) {
    stop("parameters list must contain a variable called human_population")
  }
  if (!("seed" %in% names(parameters_list))) {
    stop("parameters list must contain a variable called seed")
  }

  # Check the initial age class proportions sum to 1:
  if (sum(parameters_list$initial_proportion_child, parameters_list$initial_proportion_adult, parameters_list$initial_proportion_elderly) != 1) {
    stop("initial age class proportions do not sum to 1")
  }

  # Set the seed stored in the parameter list:
  set.seed(parameters_list$seed)

  # Store age group proportions in a single vector:
  age_group_proportions <- c(parameters_list$initial_proportion_child,
                             parameters_list$initial_proportion_adult,
                             parameters_list$initial_proportion_elderly)

  # Use the initial age class proportions to sample and create a vector of initial age classes:
  age_classes <- sample(c("child", "adult", "elderly"),
                        size = parameters_list$human_population,
                        replace = TRUE,
                        prob = age_group_proportions)

  # Return the vector of initial age classes:
  return(age_classes)

}

#' Generate a vector of school assignments for all individuals in the population
#'
#' @inheritParams create_variables
#' @param age_class_variable An `individual::CategoricalVariable` for the age classes
#'
#' @family variables
#' @export
generate_initial_schools <- function(parameters_list, age_class_variable) {

  # Check that the requisite parameters are present:
  if (!("human_population" %in% names(parameters_list))) {
    stop("parameters list must contain a variable called human_population")
  }
  if (!("seed" %in% names(parameters_list))) {
    stop("parameters list must contain a variable called seed")
  }
  if (!("school_meanlog" %in% names(parameters_list))) {
    stop("parameters list must contain a variable called school_meanlog")
  }
  if (!("school_sdlog" %in% names(parameters_list))) {
    stop("parameters list must contain a variable called school_sdlog")
  }
  if (!("school_student_staff_ratio" %in% names(parameters_list))) {
    stop("parameters list must contain a variable called school_student_staff_ratio")
  }

  set.seed(parameters_list$seed)

  # Assign children to schools
  num_children <- age_class_variable$get_size_of("child")
  index_children <- age_class_variable$get_index_of("child")$to_vector()
  school_sizes <- sample_log_normal(N = num_children,
                                    prop_max = parameters_list$school_prop_max,
                                    meanlog = parameters_list$school_meanlog,
                                    sdlog = parameters_list$school_sdlog)
  child_school_indices <- unlist(sapply(1:length(school_sizes), function(i) rep(as.character(i), school_sizes[i])))
  child_school_assignments <- sample(child_school_indices, replace = FALSE)

  # Assign staff to schools
  staff_sizes <- ceiling(school_sizes / parameters_list$school_student_staff_ratio)
  staff_school_indices <- unlist(sapply(1:length(staff_sizes), function(i) rep(as.character(i), staff_sizes[i])))
  index_adults <- age_class_variable$get_index_of("adult")$to_vector()
  index_staff <- sample(index_adults, size = sum(staff_sizes), replace = FALSE)
  staff_school_assignments <- sample(staff_school_indices, replace = FALSE)

  # School assignments for all individuals
  schools_vector <- vector(mode = "character", length = parameters_list$human_population)
  schools_vector[index_children] <- child_school_assignments
  schools_vector[schools_vector == ""] <- "0"
  schools_vector[index_staff] <- staff_school_assignments

  return(schools_vector)
}

#' Generate a vector of school assignments for all individuals in the population
#'
#' Alternative to `generate_initial_schools`. Rather than using a parametric
#' distribution, this function uses sampling with replacement from a reference
#' dataset. This is known as bootstrapping. The dataset used is [`schools_england`].
#'
#' @inheritParams generate_initial_schools
#'
#' @family variables
#' @export
generate_initial_schools_bootstrap <- function(parameters_list, age_class_variable) {

  # Check that the requisite parameters are present:
  if (!("human_population" %in% names(parameters_list))) {
    stop("parameters list must contain a variable called human_population")
  }
  if (!("seed" %in% names(parameters_list))) {
    stop("parameters list must contain a variable called seed")
  }
  if (!("school_student_staff_ratio" %in% names(parameters_list))) {
    stop("parameters list must contain a variable called school_student_staff_ratio")
  }

  # Calculating number of children and assigning them to schools
  set.seed(parameters_list$seed)
  empirical_school_sizes <- schools_england$`headcount of pupils`
  empirical_school_sizes <- empirical_school_sizes[empirical_school_sizes > 0]
  num_children <- age_class_variable$get_size_of("child") # get number of children
  index_children <- age_class_variable$get_index_of("child")$to_vector() # get the index of children in age_class_variable
  school_sizes <- c()
  remaining <- num_children

  # Sampling schools and calculating the number of children remaining to allocate
  while(remaining > 0) {
    draw <- sample(empirical_school_sizes, size = 1)
    school_sizes <- c(school_sizes, draw)
    remaining <- remaining - draw
  }

  # Correcting for instances where we overflow above the total number of children
  if(sum(school_sizes) >= num_children) {
    school_sizes[length(school_sizes)] <- school_sizes[length(school_sizes)] - (sum(school_sizes) - num_children)
  }

  # Creating schools assignment vector and randomising the ordering
  school_indices <- unlist(sapply(1:length(school_sizes), function(i) rep(as.character(i), school_sizes[i])))
  child_school_assignments <- sample(school_indices, replace = FALSE)

  # Assign staff to schools
  staff_sizes <- ceiling(school_sizes / parameters_list$school_student_staff_ratio)
  staff_school_indices <- unlist(sapply(1:length(staff_sizes), function(i) rep(as.character(i), staff_sizes[i])))
  index_adults <- age_class_variable$get_index_of("adult")$to_vector()
  index_staff <- sample(index_adults, size = sum(staff_sizes), replace = FALSE)
  staff_school_assignments <- sample(staff_school_indices, replace = FALSE)

  # School assignments for all individuals
  schools_vector <- vector(mode = "character", length = parameters_list$human_population)
  schools_vector[index_children] <- child_school_assignments
  schools_vector[schools_vector == ""] <- "0"
  schools_vector[index_staff] <- staff_school_assignments

  return(schools_vector)
}

#' Gets workplace assignments for all individuals in the population
#'
#' @inheritParams generate_initial_schools
#' @param school_variable An `individual::CategoricalVariable` for the school assignment
#'
#' @family variables
#' @export
generate_initial_workplaces <- function(parameters_list, age_class_variable, school_variable) {

  # Checking that the parameter list contains the requisite parameters
  if (!("human_population" %in% names(parameters_list))) {
    stop("parameters list must contain a variable called human_population")
  }
  if (!("seed" %in% names(parameters_list))) {
    stop("parameters list must contain a variable called seed")
  }
  if (!("workplace_prop_max" %in% names(parameters_list))) {
    stop("parameters list must contain a variable called workplace_prop_max")
  }
  if (!("workplace_a" %in% names(parameters_list))) {
    stop("parameters list must contain a variable called workplace_a")
  }
  if (!("workplace_c" %in% names(parameters_list))) {
    stop("parameters list must contain a variable called workplace_c")
  }

  # Calculating number of unassigned adults and assigning them to workplaces
  set.seed(parameters_list$seed)
  index_not_school <- school_variable$get_index_of(values = c("0"))$to_vector()
  index_adults <- age_class_variable$get_index_of("adult")$to_vector()
  index_unassigned_adults <- intersect(index_not_school, index_adults)
  workplace_sizes <- sample_offset_truncated_power_distribution(N = length(index_unassigned_adults),
                                                                prop_max = parameters_list$workplace_prop_max,
                                                                a = parameters_list$workplace_a,
                                                                c = parameters_list$workplace_c)
  workplace_indices <- unlist(sapply(1:length(workplace_sizes), function(i) rep(as.character(i), workplace_sizes[i])))
  adult_workplace_assignments <- sample(workplace_indices, replace = FALSE)

  # Workplace assignments for all individuals
  workplace_vector <- vector(mode = "character", length = parameters_list$human_population)
  workplace_vector[index_unassigned_adults] <- adult_workplace_assignments
  workplace_vector[workplace_vector == ""] <- "0"

  return(workplace_vector)
}

#' Generate a list of leisure settings that each individual visits
#'
#' Each element of this list indicates which settings each individual visits on
#' which day. The value 0 indicates that the person stays in on that day.
#'
#' @inheritParams create_variables
#'
#' @family variables
#' @export
generate_initial_leisure <- function(parameters_list, leisure_setting_sizes) {

  # Check that the requisite parameters are present:
  if (!("human_population" %in% names(parameters_list))) {
    stop("parameters list must contain a variable called human_population")
  }
  if (!("seed" %in% names(parameters_list))) {
    stop("parameters list must contain a variable called seed")
  }
  if (!("leisure_mean_size" %in% names(parameters_list))) {
    stop("parameters list must contain a variable called leisure_mean_size")
  }
  if (!("leisure_overdispersion_size" %in% names(parameters_list))) {
    stop("parameters list must contain a variable called leisure_overdispersion_size")
  }
  if (!("leisure_mean_number_settings" %in% names(parameters_list))) {
    stop("parameters list must contain a variable called leisure_mean_number_settings")
  }

  # Setting the seed
  set.seed(parameters_list$seed)

  # Calculating the number of leisure visits that each person makes per week
  leisure_visits_per_person_per_week <- rpois(n = parameters_list$human_population,
                                              lambda = parameters_list$leisure_mean_number_settings)
  leisure_visits_per_person_per_week[leisure_visits_per_person_per_week > 7] <- 7  # capping it at 1 leisure visit per day (max 7 per week)

  # Populating a list with the leisure visits made by each individual
  leisure_visit_list <- vector(mode = "list", length = parameters_list$human_population)
  for (i in 1:parameters_list$human_population) {

    # Creating a temporary vector of leisure visits for that person
    # -> Each element indicates where they visit on which day of the week
    #    and a 0 means nowhere visited on that day of the week
    temp_leisure_visit <- rep(0, 7)

    # Sampling which locations individuals visit for their leisure visits (weighted according to leisure setting size)
    temp_location_leisure_visits <- sample(x = 1:length(leisure_setting_sizes),
                                           size = leisure_visits_per_person_per_week[i],
                                           replace = FALSE,
                                           prob = leisure_setting_sizes)

    # Sampling which day(s) of the week the individual makes those visit(s) and assigning visits randomly
    days_visits_made <- sample(x = 1:7, size = leisure_visits_per_person_per_week[i], replace = FALSE)
    if (leisure_visits_per_person_per_week[i] == 1) {
      temp_leisure_visit[days_visits_made] <- temp_location_leisure_visits
    } else {
      temp_leisure_visit[days_visits_made] <- sample(x = temp_location_leisure_visits,
                                                     size = leisure_visits_per_person_per_week[i],
                                                     replace = FALSE)
    }
    leisure_visit_list[[i]] <- temp_leisure_visit
  }

  return(leisure_visit_list) # a list where each element contains a vector that specifies the ids of the leisure settings
                             # that each individual visits e.g. list(c(2, 6, 19, 35), c(1, 8), c(6, 10, 45)... etc)

}

#' Generates a vector of households for all individuals in the population
#'
#' @inheritParams generate_initial_schools
#'
#' @family variables
#' @export
generate_initial_households <- function(parameters_list, age_class_variable) {

  # Check that the requisite parameters are present:
  if (!("human_population" %in% names(parameters_list))) {
    stop("parameters list must contain a variable called human_population")
  }
  if (!("seed" %in% names(parameters_list))) {
    stop("parameters list must contain a variable called seed")
  }
  if (!("mean_household_size" %in% names(parameters_list))) {
    stop("parameters list must contain a variable called mean_household_size")
  }

  # Setting seed
  set.seed(parameters_list$seed)

  ## Checking population size N is the same as implied by age_class_variable
  if (parameters_list$human_population != age_class_variable$get_size_of(age_class_variable$get_categories())) {
    stop("Human population and age_class_vector are different lengths")
  }

  ## Extracting out the vector of underlying values from age_class_variable
  age_class_vector <- rep("", parameters_list$human_population)
  age_class_vector[age_class_variable$get_index_of("child")$to_vector()] <- "child"
  age_class_vector[age_class_variable$get_index_of("adult")$to_vector()] <- "adult"
  age_class_vector[age_class_variable$get_index_of("elderly")$to_vector()] <- "elderly"

  ## Track which individuals are assigned
  assigned <- rep(FALSE, parameters_list$human_population)
  individual_households <- rep(NA, parameters_list$human_population)
  household_counter <- 1

  ## Looping over this whilst there still remain any unassigned individuals
  while(sum(assigned) < parameters_list$human_population) {

    # Check if only children are left unassigned - if this is the case, then we just distribute
    # them randomly across households
    unassigned_indices <- which(!assigned)
    if(all(age_class_vector[unassigned_indices] == "child")) {
      # Distribute remaining children across existing households randomly
      for(child_idx in unassigned_indices) {
        selected_household <- sample(household_counter, 1)
        assigned[child_idx] <- TRUE
        individual_households[child_idx] <- selected_household
      }
      break # Exit the main loop as all remaining unassigned individuals are children and have been assigned
    }

    # Draw household size
    household_size <- rpois(n = 1, lambda = parameters_list$mean_household_size)

    # Initialize temporary household storage
    temp_household <- c()

    ## Looping over this whilst current household isn't full
    while(length(temp_household) < household_size && sum(assigned) < parameters_list$human_population) {

      # Randomly select an unassigned individual
      candidates <- which(!assigned)
      selected <- sample(x = candidates, size = 1)

      # Ensure selected individual meets the household formation criteria (i.e. children have to have at least 1 adult in household)
      if(age_class_vector[selected] == "child") {

        ## Check whether current household has an adult - if it does, just add the child
        if(sum(age_class_vector[temp_household] == "adult") >= 1) {
          temp_household <- c(temp_household, selected)
          assigned[selected] <- TRUE
        } else { # if not, get an adult to be added to the household
          # Ensure there is at least one unassigned adult to pair with
          unassigned_adults <- which(age_class_vector == "adult" & !assigned)
          if(length(unassigned_adults) < 1) {
            # No available adults to pair with the child, break from the inner loop
            break
          }
          # Pair child with adult(s)
          num_adults_to_add <- 1
          adults_to_add <- sample(unassigned_adults, num_adults_to_add)
          temp_household <- c(temp_household, selected, adults_to_add)
          assigned[c(selected, adults_to_add)] <- TRUE
        }

      } else {
        # Add the individual to the household if there's enough space
        if((length(temp_household) + 1) <= household_size) {
          temp_household <- c(temp_household, selected)
          assigned[selected] <- TRUE
        }
      }
    }
    # Add the completed household to the list of households, if any members were added
    if(length(temp_household) > 0) {
      individual_households[temp_household] <- household_counter
      household_counter <- household_counter + 1
    }
    # print(sum(assigned))
  }

  return(individual_households = individual_households)
}

#' Generates a vector of households for all individuals in the population
#'
#' Alternative to [generate_initial_households()]. Rather than using a parametric
#' distribution, this function uses sampling with replacement from a reference
#' dataset. This is known as bootstrapping. The dataset used is
#' [`baseline_household_demographics`]. Unlike [generate_initial_households()],
#' this function generates both the household and age class assignments together.
#'
#' @inheritParams create_variables
#'
#' @family variables
#' @export
generate_initial_households_bootstrap <- function(parameters_list) {

  ## Checking country is either "UK" or "USA"
  country <- parameters_list$household_distribution_country
  if (!(country %in% c("UK", "USA"))) {
    stop("Country specified must be either USA or UK")
  }

  ## Using data from RTI's synthetic population for San Francisco to bootstrap https://fred.publichealth.pitt.edu/syn_pops
  if (country == "USA") {
    ref_panel <- baseline_household_demographics_usa
  } else if (country == "UK") {   ## Using Hinch et al's synthetic population from ONS
    ref_panel <- baseline_household_demographics_uk
  }

  # Creating blank age-class vectors and household assignment vectors to populate
  age_class_vector <- rep("", parameters_list$human_population)
  individual_households <- rep(NA, parameters_list$human_population)

  ## Looping over this whilst there still remain any unassigned individuals
  counter <- 1
  household_counter <- 1
  while(counter <= parameters_list$human_population) {

    ## Sampling a random household from the reference panel
    temp_index <- sample(1:nrow(ref_panel), 1, replace = TRUE)
    random_household <- ref_panel[temp_index, ]

    ## Expanding out the random household
    household_age_individuals <- rep(x = names(random_household), times = random_household)
    for (i in 1:length(household_age_individuals)) {
      age_class_vector[counter] <- household_age_individuals[i]
      individual_households[counter] <- household_counter
      counter <- counter + 1
    }
    household_counter <- household_counter + 1
  }

  ## Checking if there are any NAs or missing age_class assignments - if there are, randomly assigning
  ## them to houses and age-groups
  if (sum(is.na(individual_households)) > 0) {
    index_unassigned <- which(is.na(individual_households))
    if(length(index_unassigned) > 3) {
      stop("too many NAs in household generation - check this")
    }
    individual_households[index] <- sample(x = 1:max(individual_households), size = length(index_unassigned), replace = TRUE)
    age_class_vector[index] <- sample(x = unique(age_class_vector), size = length(index_unassigned), replace = TRUE,
                                      prob = unname(table(age_class_vector)) / parameters_list$human_population)
  }

  ## Scrambling the order of individuals so that household members don't appear right next to each other
  ## -> This might not be needed, need to give this some thought
  scrambled_index <- sample(x = 1:parameters_list$human_population,
                            size = parameters_list$human_population,
                            replace = FALSE)

  return(list(individual_households = individual_households[scrambled_index],
              age_class_vector = age_class_vector[scrambled_index]))

}

