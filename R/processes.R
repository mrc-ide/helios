#' Define and create the model processes
#'
#' @param parameters A list of model parameters as generated by `get_parameters`
#' @param variables A list of model variables as generated by `create_variables`
#' @param events list of the model events as generated by `create_events`
#'
#' @export
create_processes <- function(
    parameters,
    variables,
    events) {

  # Open a list of processes to store the model processes in:
  processes <- list(

    # ===============================
    # Disease State Progression
    # ===============================
    SE_process = SE_process(parameters = parameters,
                            variables = variables),

    EI_process = EI_process(parameters = parameters,
                            variables = variables,
                            events = events),

    IR_process = IR_process(parameters = parameters,
                            variables = variables,
                            events = events)

    # ===============================
    # Intervention processes
    # ===============================


    # ===============================
    # Rendering processes
    # ===============================
    # health_render_process

  )

  # Return the model processes:
  return(processes)

}

#' Create the process governing the transition of susceptible individuals to the exposed disease state:
#'
#' @param parameters A list of model parameters as generated by `get_parameters`
#' @param variables A list of model variables as generated by `create_variables`
#'
#' @export
SE_process <- function(parameters, variables){

  function(t) {

    # Retrieve the indices of Infected individuals:
    I <- variables$disease_state$get_index_of("I")

    #=== Household FOI ===#
    #=====================#
    # Open vector to store household FOIs experienced by each individual
    household_FOI <- vector(mode = "numeric", length = parameters$human_population)

    # Store the number of households:
    num_households <- max(as.numeric(variables$household$get_categories()))

    # Calculate the household FOI for each individual (if HH size = 1, FOI = 0)
    for (i in seq(num_households)) {

      # Retrieve the indices of individuals in the i-th household
      spec_household <- variables$household$get_index_of(as.character(i))

      # Retrieve the indices of all infectious individuals in the i-th household
      spec_household_I <- I$and(spec_household)

      #  Calculate the FOI for the i-th household
      spec_household_FOI <- parameters$beta_household * spec_household_I$size() / spec_household$size() ## this calculation needs more in it

      # Assign the i-th households FOI to the indices of the individuals residing in that household
      household_FOI[spec_household$to_vector()] <- spec_household_FOI
    }

    #=== Workplace FOI ===#
    #=====================#

    # Open an empty vector for the workplace FOI for each individual:
    workplace_FOI <- vector(mode = "numeric", length = parameters$human_population)

    # Store the number of households:
    num_workplaces <- max(as.numeric(variables$workplace$get_categories()))

    # Retrieve the indices of all adults in the current population (only adult age class work):
    # adults_subset <- variables$age_class$get_index_of("adult")

    # Get the indices of all individuals with a workplace (0's have no workplace):
    workplace_adults_only_var <- variables$workplace$get_index_of(as.character(1:max(num_workplaces)))

    # For each workplace:
    for (i in seq(num_workplaces)) {

      # Get the indices of individuals that work in the i-th workplace:
      spec_workplace <- variables$workplace$get_index_of(as.character(i))

      # Get the indices of infectious individuals in the i-th workplace:
      spec_workplace_I <- I$and(spec_workplace)

      # Calculate the workplace-specific FOI of the i-th workplace:
      spec_workplace_FOI <- parameters$beta_workplace * spec_workplace_I$size() / spec_workplace$size() ## this calculation needs more in it

      # Store the workplace-specific FOR in the indices of all individuals that work there:
      workplace_FOI[spec_workplace$to_vector()] <- spec_workplace_FOI
    }

    #=== School FOI ===#
    #==================#

    # Open empty vector to store each individuals school-specific FOI:
    school_FOI <- vector(mode = "numeric", length = parameters$human_population)

    # Get the number of schools:
    num_schools <- max(as.numeric(variables$school$get_categories()))

    # Subset the indices of all children:
    # child_subset <- variables$age_class$get_index_of("child")

    # Retrieve the index of all individuals with a school (0's have no school):
    school_child_only_var <- variables$school$get_index_of(as.character(1:max(num_schools)))

    # For each school:
    for (i in seq(num_schools)) {

      # Retrieve the indices of children in the i-th school
      spec_school <- variables$school$get_index_of(as.character(i))

      # Retrieve the indices of all infectious individuals in the i-th school:
      spec_school_I <- I$and(spec_school)

      # Calculate the school-specific FOI for the i-th school:
      spec_school_FOI <- parameters$beta_school * spec_school_I$size() / spec_school$size() ## this calculation needs more in it

      # Store the school-specific FOI at the indices of all children that attend it:
      school_FOI[spec_school$to_vector()] <- spec_school_FOI
    }

    #=== Leisure FOI ===#
    #=====================#
    ## IMPORTANT NOTE:
    ## Currently I think this will be updated every time-step which isn't quite right - we need this calculated
    ## only at the beginning of a new day.
    ## I think we can also possibly save computational cost generally by only doing all of the FOI calculations
    ## for individuals who are susceptible. Unclear how much of a speed boost that will bring us.
    ## Also - do we need to take into account fact some people might visit different times of the day?
    ## Unclear - probably leave this for now.

    # Creating vector to store which leisure setting individuals visit on a given timestep (NOTE we need to change this so that it's day)
    leisure_visit <- vector(mode = "numeric", length = parameters$human_population)

    # For each individual, work out which leisure setting they go to that particular night - 0 = they don't go to any
    for (i in seq(parameters$human_population)) {

      # Which leisure settings do individuals have associated with them (and could visit)
      potential_leisure_visits <- variables$leisure$get_values(i)

      # How many leisure settings do individuals have associated with them (and could visit)
      number_potential_leisure_visits <- length(potential_leisure_visits)

      # What's the probability of visiting each potential setting (considered equal) and the probability of visiting none (staying home)
      # (probability of staying home is given by 1 - parameters$leisure_prob_visit)
      prob_visiting_each <- parameters$leisure_prob_visit / number_potential_leisure_visits

      # Sampling wich leisure setting actually visited (0 = visit none and staying home)
      leisure_visit[i] <- sample(x = c(0, seq(number_potential_leisure_visits)),
                                 size = 1,
                                 prob = c(1 - parameters$leisure_prob_visit,
                                          rep(prob_visiting_each, number_potential_leisure_visits)))
    }

    # Open empty vector to store each individuals leisure-specific FOI:
    leisure_FOI <- vector(mode = "numeric", length = parameters$human_population)

    # Get all unique leisure settings actually visited in this timestep (NOTE: we need to change this to day)
    leisure_settings_visited <- unique(leisure_visit)

    # Create temporary leisure variable that contains leisure settings visited in that day
    temp_leisure_variable <- CategoricalVariable$new(categories = leisure_settings_visited,
                                                     initial_values = leisure_visit)

    # Calculating leisure-specific FOI for each individual
    for (i in 1:length(leisure_settings_visited)) {

      # Access the index of the specific leisure setting being considered
      spec_leisure_setting <- leisure_settings_visited[i]

      # Only going through below steps if leisure setting actually visited (i.e. != 0)
      if (spec_leisure_setting != 0) {

        # Retrieve the indices of individuals visiting the specific leisure setting
        spec_leisure <- temp_leisure_variable$get_index_of(as.character(spec_leisure_setting))

        # Retrieve the indices of all infectious individuals in the particular leisure setting being considered
        spec_leisure_I <- I$and(spec_leisure)

        # Calculate the school-specific FOI for the i-th school:
        spec_leisure_FOI <- parameters$beta_leisure * spec_leisure_I$size() / spec_leisure$size() ## this calculation needs more in it

        # Store the school-specific FOI at the indices of all children that attend it:
        leisure_FOI[spec_leisure$to_vector()] <- spec_leisure_FOI
      }

    }

    #=== Community FOI ===#
    #=====================#
    ### Calculate Community FOI (real-valued for all individuals)
    #### NOTE: Double check whether the "/N" is correct here - not sure currently
    community_FOI <- parameters$beta_community * variables$disease_state$get_size_of("I") / parameters$human_population

    #=== Total FOI ===#
    #=================#

    # Sum the household, workplace, school leisure, and community FOIs to get the total FOI for each
    # individual:
    total_FOI <- household_FOI + workplace_FOI + school_FOI + leisure_FOI + community_FOI

    # Calculate the probability of getting infected in the current interval for each individual:
    p_inf <- 1 - exp(-total_FOI * parameters$dt)

    # Get the indices of all susceptible individuals in the current timestep:
    S <- variables$disease_state$get_index_of("S")

    # Get the infection probability for each currently susceptible individual:
    p_inf_currently_S <- p_inf[S$to_vector()]

    # Sample susceptible individuals using their infection probability to determine who gets infected:
    S$sample(rate = p_inf_currently_S)

    # Queue an update to the infectious state of the newly infected susceptible individuals to Exposed:
    variables$disease_state$queue_update(value = "E",index = S)

  }
}


#' Create the process governing the transition of exposed individuals to the infectious disease state:
#'
#' @param parameters A list of model parameters as generated by `get_parameters`
#' @param variables A list of model variables as generated by `create_variables`
#' @param events list of the model events as generated by `create_events`
#'
#' @export
EI_process <- function(parameters, variables, events){

  function(t) {

    # Get the indices of all exposed individuals:
    E <- variables$disease_state$get_index_of("E")

    # Get the indices of exposed individuals for which transitions to I have been scheduled:
    EI_already_scheduled <- events$EI_event$get_scheduled()

    # Get the indices of all exposed individuals with progression to I already scheduled:
    E$and(EI_already_scheduled$not(inplace = TRUE))

    # Calculate the delay until each exposed individual without a delay transitions to infected:
    I_times <- round((rgamma(E$size(), 2 * parameters$duration_exposed, 2) + 1) / parameters$dt)

    # Schedule the new transitions from exposed to infected:
    events$EI_event$schedule(target = E, delay = I_times)

  }
}

#' Create the process governing the transition of infectious individuals to recovered disease state:
#'
#' @param parameters A list of model parameters as generated by `get_parameters`
#' @param variables A list of model variables as generated by `create_variables`
#' @param events A list of model events as generated by `create_events`
#'
#' @export
IR_process <- function(parameters, variables, events) {

  function(t){

    # Get the indices of currently infectious individuals:
    I <- variables$disease_state$get_index_of("I")

    # Get the indices of individuals with I to R transitions already scheduled:
    IR_already_scheduled <- events$IR_event$get_scheduled()

    # Get the indices of infectious individuals without I to R transitions already scheduled:
    I$and(IR_already_scheduled$not(inplace = TRUE))

    # Calculate recovery times for infectious individuals without transitions scheduled:
    R_times <- round((rgamma(I$size(), 2 * parameters$duration_infectious, 1) + 1) / parameters$dt)

    # Schedule the recovery events for infectious individuals without transitions scheduled:
    events$IR_event$schedule(target = I, delay = R_times)

  }
}

# Define the process which renders the number of individuals in each time step:
# disease_state_count_render_process <- function(renderers, parameters, variables) {
#
#   # Create the disease state count render
#   disease_state_count_render <- Render$new(timesteps = round(parameters$simulation_time / parameters$dt))
#   disease_states <- variables$disease_state$get_categories()
#   function(t) {
#     for (i in disease_states) {
#       disease_state_count_render$render(paste0(i, '_count'), variables$disease_state$get_size_of(i), t)
#     }
#   }
# }

