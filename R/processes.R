#' Define and create all model processes
#'

#' @param variables_list A list of model variables as generated by [create_variables()]
#' @param events_list A list of the model events as generated by [create_events()]
#' @param parameters_list A list of model parameters as generated by [get_parameters()]
#' @param renderer An individual-package render object
#'
#' @family processes
#' @export
create_processes <- function(variables_list, events_list, parameters_list, renderer) {

  # Open a list of processes to store the model processes in:
  processes_list <- list(

    # ===============================
    # Disease State Progression
    # ===============================
    SE_process = create_SE_process(variables_list = variables_list,
                                   events_list = events_list,
                                   parameters_list = parameters_list,
                                   renderer = renderer),

    EI_process = create_EI_process(variables_list = variables_list,
                                   events_list = events_list,
                                   parameters_list = parameters_list),

    IR_process = create_IR_process(variables_list = variables_list,
                                   events_list = events_list,
                                   parameters_list = parameters_list)

  )

  # ===============================
  # ENDEMIC DISEASE MODE
  # ===============================
  if (parameters_list$endemic_or_epidemic == "endemic") {
    processes_list <- c(processes_list,
                        list(RS_process = create_RS_process(variables_list = variables_list,
                                                            events_list = events_list,
                                                            parameters_list = parameters_list)),
                        list(external_source_process = create_external_source_process(variables_list = variables_list,
                                                                                      events_list = events_list,
                                                                                      parameters_list = parameters_list,
                                                                                      renderer = renderer)))
  }

  # ===============================
  # Rendering processes
  # ===============================
  # health_render_process
  processes_list <- c(
    processes_list,
    individual::categorical_count_renderer_process(
      renderer,
      variables_list$disease_state,
      c('S', 'E', 'I', 'R')
    )
  )

  # Return the model processes:
  return(processes_list)

}

#' Create process governing susceptible to exposed disease state transition
#'
#' @inheritParams create_processes
#'
#' @family processes
#' @export
create_SE_process <- function(variables_list, events_list, parameters_list, renderer){

  ## Pre-calculating the things that only have to be calculated once

  ##### HOUSEHOLDS #####
  # Calculate the number of households:
  num_households <- max(as.numeric(variables_list$household$get_categories()))

  # Retrieve and store the indices of individuals in the i-th household
  household_bitset_list <- vector(mode = "list", length = num_households)
  household_index_list <- vector(mode = "list", length = num_households)
  household_size_list <- vector(mode = "list", length = num_households)
  for (i in seq(num_households)) {
    household_bitset_list[[i]] <- variables_list$household$get_index_of(as.character(i))
    household_index_list[[i]] <- household_bitset_list[[i]]$to_vector()
    household_size_list[[i]] <- length(household_index_list[[i]])
  }

  # Creating vector of setting-specific riskinesses for households
  household_specific_riskiness <- generate_setting_specific_riskinesses(parameters_list = parameters_list,
                                                                        setting = "household",
                                                                        number_of_locations = num_households)

  ##### WORKPLACES #####
  # Calculate the number of workplaces:
  num_workplaces <- max(as.numeric(variables_list$workplace$get_categories()))

  # Retrieve and store the indices of individuals in the i-th household
  workplace_bitset_list <- vector(mode = "list", length = num_workplaces)
  workplace_index_list <- vector(mode = "list", length = num_workplaces)
  workplace_size_list <- vector(mode = "list", length = num_workplaces)
  for (i in seq(num_workplaces)) {
    workplace_bitset_list[[i]] <- variables_list$workplace$get_index_of(as.character(i))
    workplace_index_list[[i]] <- workplace_bitset_list[[i]]$to_vector()
    workplace_size_list[[i]] <- length(workplace_index_list[[i]])
  }

  # Creating vector of setting-specific riskinesses for households
  workplace_specific_riskiness <- generate_setting_specific_riskinesses(parameters_list = parameters_list,
                                                                        setting = "workplace",
                                                                        number_of_locations = num_workplaces)

  ##### SCHOOLS #####
  # Calculate the number of schools:
  num_schools <- max(as.numeric(variables_list$school$get_categories()))

  # Retrieve and store the indices of individuals in the i-th household
  school_bitset_list <- vector(mode = "list", length = num_schools)
  school_index_list <- vector(mode = "list", length = num_schools)
  school_size_list <- vector(mode = "list", length = num_schools)
  for (i in seq(num_schools)) {
    school_bitset_list[[i]] <- variables_list$school$get_index_of(as.character(i))
    school_index_list[[i]] <- school_bitset_list[[i]]$to_vector()
    school_size_list[[i]] <- length(school_index_list[[i]])
  }

  # Generate vector of setting-specific riskinesses for schools
  school_specific_riskiness <- generate_setting_specific_riskinesses(parameters_list = parameters_list,
                                                                     setting = "school",
                                                                     number_of_locations = num_schools)

  ##### LEISURE #####
  # Leisure occupancy is dynamically updated each day, so we don't calculate that here.
  # Still need to calculate setting-specific riskiness, which we do calculate here.

  # Calculate the number of leisure:
  num_leisure <- length(parameters_list$setting_sizes$leisure)

  # Creating vector of setting-specific riskinesses for leisure settings
  leisure_specific_riskiness <- generate_setting_specific_riskinesses(parameters_list = parameters_list,
                                                                      setting = "leisure",
                                                                      number_of_locations = num_leisure)

  ## Process Function
  function(t) {

    ## Bitset for all infectious individuals
    I <- variables_list$disease_state$get_index_of("I")

    #=== Household FOI ===#
    #=====================#
    # Open vector to store household FOIs experienced by each individual
    household_FOI <- vector(mode = "numeric", length = parameters_list$human_population)

    # Calculate the household FOI for each individual (if HH size = 1, FOI = 0)
    for (i in seq(num_households)) {

      # Retrieve the bitset of individuals in the i-th household
      spec_household <- household_bitset_list[[i]]

      # Retrieve the bitset of all infectious individuals in the i-th household
      spec_household_I <- I$copy()$and(spec_household)

      #  Calculate the FOI for the i-th household - with and without farUVC installed
      if (parameters_list$far_uvc_household & parameters_list$uvc_household[i] == 1 & t > parameters_list$far_uvc_household_timestep) {
        spec_household_FOI <- household_specific_riskiness[i] * (1 - parameters_list$far_uvc_household_efficacy) * (parameters_list$beta_household * spec_household_I$size() / household_size_list[[i]])
      } else {
        spec_household_FOI <- household_specific_riskiness[i] * parameters_list$beta_household * spec_household_I$size() / household_size_list[[i]]
      }

      # Assign the i-th households FOI to the indices of the individuals residing in that household
      household_FOI[household_index_list[[i]]] <- spec_household_FOI
    }

    #=== Workplace FOI ===#
    #=====================#

    # Open an empty vector for the workplace FOI for each individual:
    workplace_FOI <- vector(mode = "numeric", length = parameters_list$human_population)

    # For each workplace:
    for (i in seq(num_workplaces)) {

      # Get the indices of individuals that work in the i-th workplace:
      spec_workplace <- workplace_bitset_list[[i]]

      # Get the indices of infectious individuals in the i-th workplace:
      spec_workplace_I <- I$copy()$and(spec_workplace)

      # Calculate the workplace-specific FOI of the i-th workplace - with and without farUVC installed
      if (parameters_list$far_uvc_workplace & parameters_list$uvc_workplace[i] == 1 & t > parameters_list$far_uvc_workplace_timestep) {
        spec_workplace_FOI <- workplace_specific_riskiness[i] * (1 - parameters_list$far_uvc_workplace_efficacy) * (parameters_list$beta_workplace * spec_workplace_I$size() / workplace_size_list[[i]])
      } else {
        spec_workplace_FOI <- workplace_specific_riskiness[i] * parameters_list$beta_workplace * spec_workplace_I$size() / workplace_size_list[[i]]
      }

      # Store the workplace-specific FOR in the indices of all individuals that work there:
      workplace_FOI[workplace_index_list[[i]]] <- spec_workplace_FOI
    }

    #=== School FOI ===#
    #==================#

    # Open empty vector to store each individuals school-specific FOI:
    school_FOI <- vector(mode = "numeric", length = parameters_list$human_population)

    # For each school:
    for (i in seq(num_schools)) {

      # Retrieve the indices of children in the i-th school
      spec_school <- school_bitset_list[[i]]

      # Retrieve the indices of all infectious individuals in the i-th school:
      spec_school_I <- I$copy()$and(spec_school)

      # Calculate the school-specific FOI for the i-th school - with and without farUVC installed
      if (parameters_list$far_uvc_school & parameters_list$uvc_school[i] == 1 & t > parameters_list$far_uvc_school_timestep) {
        spec_school_FOI <- school_specific_riskiness[i] * (1 - parameters_list$far_uvc_school_efficacy) * (parameters_list$beta_school * spec_school_I$size() / school_size_list[[i]])
      } else {
        spec_school_FOI <- school_specific_riskiness[i] * parameters_list$beta_school * spec_school_I$size() / school_size_list[[i]]
      }

      # Store the school-specific FOI at the indices of all children that attend it:
      school_FOI[school_index_list[[i]]] <- spec_school_FOI
    }

    #=== Leisure FOI ===#
    #=====================#
    if ((t * parameters_list$dt) == floor((t * parameters_list$dt))) {

      # Creating vector to store which leisure setting individuals visit on a given day
      leisure_visit <- vector(mode = "numeric", length = parameters_list$human_population)

      # For each individual, work out which leisure setting they go to that particular day. 0 = they don't go to any
      for (i in seq(parameters_list$human_population)) {

        # Which leisure settings do individuals have associated with them (and could visit)
        potential_leisure_visits <- variables_list$leisure$get_values(i)

        # Sampling which leisure setting actually visited (0 = visit none and staying home)
        leisure_visit[i] <- sample(x = unlist(potential_leisure_visits), size = 1)
      }

      # Updating the leisure setting visited that day
      ## Note that we include all leisure settings as categories irrespective of whether they're visited on a particular day
      ## Doesn't affect the FOI calculation, as places with no visits on a day don't update the FOI vector
      ## Also note that parameters_list$leisure_indices aren't 1:num_leisure as i) it includes 0 (no leisure visited); and
      ## 2) as part of the leisure variable creation in variables.R, some initially created leisure settings
      ##    don't feature in the RaggedInteger vector, and so these setting #s are removed as indices.
      variables_list$specific_leisure$initialize(categories = as.character(parameters_list$leisure_indices),
                                                 initial_values = as.character(leisure_visit)) #  update the states with leisure_visit for that day
    }

    # Open empty vector to store each individuals leisure-specific FOI:
    leisure_FOI <- vector(mode = "numeric", length = parameters_list$human_population)

    # Calculating leisure-specific FOI for each individual
    ## Note that we include all possible leisure settings as categories irrespective of whether they're visited on a particular day
    ## Doesn't affect the FOI calculation, as places with no visits on a day don't update the FOI vector (FOI is NaN which doesn't index in a vector)
    ## And note that we're specifically looping through the indices of each leisure setting (for reasons described above)
    leisure_settings <-  variables_list$specific_leisure$get_categories()
    leisure_settings <- leisure_settings[leisure_settings != "0"] # removing the "0" category which is not visited
    for (i in 1:length(leisure_settings)) {

      # Access the index of the specific leisure setting being considered
      spec_leisure_setting <- as.numeric(leisure_settings[i])

      # Only going through below steps if leisure setting actually visited (i.e. != 0)
      if (spec_leisure_setting != 0) {

        # Retrieve the indices of individuals visiting the specific leisure setting
        spec_leisure <- variables_list$specific_leisure$get_index_of(as.character(spec_leisure_setting))

        # Retrieve the indices of all infectious individuals in the particular leisure setting being considered
        spec_leisure_I <- I$copy()$and(spec_leisure)

        # Calculate the leisure-specific FOI for the i-th leisure setting - with and without farUVC installed
        ## Note that leisure_specific_riskiness uses indices 1:num_leisure to index the leisure settings
        ## (this is in contrast to leisure_indices, which uses the original indices from their generation,
        ##  and which span 1 to max(leisure_indices) with some gaps)
        ## WILL NEED TO CHECK far_uvc_leisure[i] is correct once Adam's PR is in for the same reason
        if (parameters_list$far_uvc_leisure & parameters_list$uvc_leisure[i] == 1 & t > parameters_list$far_uvc_leisure_timestep) {
          spec_leisure_FOI <- leisure_specific_riskiness[i] * (1 - parameters_list$far_uvc_leisure_efficacy) * (parameters_list$beta_leisure * spec_leisure_I$size() / spec_leisure$size()) ## this calculation needs more in it
        } else {
          spec_leisure_FOI <- leisure_specific_riskiness[i] * parameters_list$beta_leisure * spec_leisure_I$size() / spec_leisure$size() ## this calculation needs more in it
        }

        # Store the leisure setting-specific FOI at the indices of all individuals that attend it:
        leisure_FOI[spec_leisure$to_vector()] <- spec_leisure_FOI
      }

    }

    #=== Community FOI ===#
    #=====================#
    ### Calculate Community FOI (real-valued for all individuals)
    #### NOTE: Double check whether the "/N" is correct here - not sure currently
    community_FOI <- parameters_list$beta_community * variables_list$disease_state$get_size_of("I") / parameters_list$human_population

    #=== Total FOI ===#
    #=================#

    # Sum the household, workplace, school leisure, and community FOIs to get the total FOI for each
    # individual:
    total_FOI <- household_FOI + workplace_FOI + school_FOI + leisure_FOI + community_FOI

    # Render the setting-specific FOIs is diagnostic rendering turned on:
    if(parameters_list$render_diagnostics) {
      renderer$render('FOI_household', max(household_FOI), t)
      renderer$render('FOI_workplace', max(workplace_FOI), t)
      renderer$render('FOI_school', max(school_FOI), t)
      renderer$render('FOI_leisure', max(leisure_FOI), t)
      renderer$render('FOI_community', max(community_FOI), t)
      renderer$render('FOI_total', max(total_FOI), t)
    }

    # Calculate the probability of getting infected in the current interval for each individual:
    p_inf <- 1 - exp(-total_FOI * parameters_list$dt)

    # Get the indices of all susceptible individuals in the current timestep:
    S <- variables_list$disease_state$get_index_of("S")

    # Get the infection probability for each currently susceptible individual:
    p_inf_currently_S <- p_inf[S$to_vector()]

    # Sample susceptible individuals using their infection probability to determine who gets infected:
    S$sample(rate = p_inf_currently_S)

    # Render the number of people going from susceptible to infected:
    renderer$render('E_new', S$size(), t)

    # Queue an update to the infectious state of the newly infected susceptible individuals to Exposed:
    variables_list$disease_state$queue_update(value = "E",index = S)

  }
}


#' Create process governing exposed to infectious disease state transition
#'
#' @inheritParams create_processes
#'
#' @family processes
#' @export
create_EI_process <- function(variables_list, events_list, parameters_list){

  function(t) {

    # Get the indices of all exposed individuals:
    E <- variables_list$disease_state$get_index_of("E")

    # Get the indices of exposed individuals for which transitions to I have been scheduled:
    EI_already_scheduled <- events_list$EI_event$get_scheduled()

    # Get the indices of all exposed individuals with progression to I already scheduled:
    E$and(EI_already_scheduled$not(inplace = TRUE))

    # Calculate the delay until each exposed individual without a delay transitions to infected:
    I_times <- round((rgamma(E$size(), 2 * parameters_list$duration_exposed, 2) + 1) / parameters_list$dt)

    # Schedule the new transitions from exposed to infected:
    events_list$EI_event$schedule(target = E, delay = I_times)

  }
}

#' Create process governing infectious to recovered disease state transition
#'
#' @inheritParams create_processes
#'
#' @family processes
#' @export
create_IR_process <- function(variables_list, events_list, parameters_list) {

  function(t){

    # Get the indices of currently infectious individuals:
    I <- variables_list$disease_state$get_index_of("I")

    # Get the indices of individuals with I to R transitions already scheduled:
    IR_already_scheduled <- events_list$IR_event$get_scheduled()

    # Get the indices of infectious individuals without I to R transitions already scheduled:
    I$and(IR_already_scheduled$not(inplace = TRUE))

    # Calculate recovery times for infectious individuals without transitions scheduled:
    R_times <- round((rgamma(I$size(), 2 * parameters_list$duration_infectious, 2) + 1) / parameters_list$dt)

    # Schedule the recovery events for infectious individuals without transitions scheduled:
    events_list$IR_event$schedule(target = I, delay = R_times)

  }
}

#' Create process governing recovered (and immune) back to susceptible disease state transition
#'
#' @inheritParams create_processes
#'
#' @family processes
#' @export
create_RS_process <- function(variables_list, events_list, parameters_list) {

  function(t){

    # Get the indices of currently recovered and immune individuals:
    R <- variables_list$disease_state$get_index_of("R")

    # Get the indices of individuals with I to R transitions already scheduled:
    RS_already_scheduled <- events_list$RS_event$get_scheduled()

    # Get the indices of infectious individuals without I to R transitions already scheduled:
    R$and(RS_already_scheduled$not(inplace = TRUE))

    # Calculate recovery times for infectious individuals without transitions scheduled:
    S_times <- round((rgamma(R$size(), 2 * parameters_list$duration_immune, 2) + 1) / parameters_list$dt)

    # Schedule the recovery events for infectious individuals without transitions scheduled:
    events_list$RS_event$schedule(target = R, delay = S_times)

  }
}

#' Create process governing exposed to infectious disease state transition
#'
#' @inheritParams create_processes
#'
#' @family processes
#' @export
create_external_source_process <- function(variables_list, events_list, parameters_list, renderer){

  function(t) {

    # Get the indices of all susceptible individuals:
    S <- variables_list$disease_state$get_index_of("S")

    # Calculate the probability of getting infected in the current interval for each individual:
    p_inf_ext <- 1 - exp(-parameters_list$prob_inf_external * parameters_list$dt)

    # Sample susceptible individuals using their infection probability to determine who gets infected:
    S$sample(rate = p_inf_ext)

    # Queue an update to the infectious state of the newly infected susceptible individuals to Exposed:
    variables_list$disease_state$queue_update(value = "E",index = S)

    # Render the number of individuals infected through the external mechanism
    renderer$render('n_external_infections', S$size(), t)

  }
}
