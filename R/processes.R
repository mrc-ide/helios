#' Define and create the model processes
#'
#' @param variables_ist A list of model variables as generated by `create_variables`
#' @param events_list list of the model events as generated by `create_events`
#' @param parameters_list A list of model parameters as generated by `get_parameters`
#' @param renderer An individual-package render object
#'
#' @export
create_processes <- function(
    variables_list,
    events_list,
    parameters_list,
    renderer) {

  # Open a list of processes to store the model processes in:
  processes_list <- list(

    # ===============================
    # Disease State Progression
    # ===============================
    SE_process = create_SE_process(variables_list = variables_list,
                                   events_list = events_list,
                                   parameters_list = parameters_list),

    EI_process = create_EI_process(variables_list = variables_list,
                                   events_list = events_list,
                                   parameters_list = parameters_list),

    IR_process = create_IR_process(variables_list = variables_list,
                                   events_list = events_list,
                                   parameters_list = parameters_list)

  )

  ## Adding RS_process in if endemic pathogen is required
  if (parameters_list$endemic_or_epidemic == "endemic") {
    processes_list <- c(processes_list,
                        list(RS_process = create_RS_process(variables_list = variables_list,
                                                            events_list = events_list,
                                                            parameters_list = parameters_list)))
  }

  # ===============================
  # Rendering processes
  # ===============================
  # health_render_process
  processes_list <- c(
      processes_list,
      individual::categorical_count_renderer_process(
        renderer,
        variables_list$disease_state,
        c('S', 'E', 'I', 'R')
      )
    )

  # Return the model processes:
  return(processes_list)

}

#' Create the process governing the transition of susceptible individuals to the exposed disease state:
#'
#' @param variables_list A list of model variables as generated by `create_variables`
#' @param events_list list of the model events as generated by `create_events`
#' @param parameters_list A list of model parameters as generated by `get_parameters`
#'
#' @export
create_SE_process <- function(variables_list, events_list, parameters_list){

  ## Pre-calculating the things that only have to be calculated once

  ##### HOUSEHOLDS #####
  # Calculate the number of households:
  num_households <- max(as.numeric(variables_list$household$get_categories()))

  # Retrieve and store the indices of individuals in the i-th household
  household_bitset_list <- vector(mode = "list", length = num_households)
  household_index_list <- vector(mode = "list", length = num_households)
  household_size_list <- vector(mode = "list", length = num_households)
  for (i in seq(num_households)) {
    household_bitset_list[[i]] <- variables_list$household$get_index_of(as.character(i))
    household_index_list[[i]] <- household_bitset_list[[i]]$to_vector()
    household_size_list[[i]] <- length(household_index_list[[i]])
  }

  ##### WORKPLACES #####
  # Calculate the number of workplaces:
  num_workplaces <- max(as.numeric(variables_list$workplace$get_categories()))

  # Retrieve and store the indices of individuals in the i-th household
  workplace_bitset_list <- vector(mode = "list", length = num_workplaces)
  workplace_index_list <- vector(mode = "list", length = num_workplaces)
  workplace_size_list <- vector(mode = "list", length = num_workplaces)
  for (i in seq(num_workplaces)) {
    workplace_bitset_list[[i]] <- variables_list$workplace$get_index_of(as.character(i))
    workplace_index_list[[i]] <- workplace_bitset_list[[i]]$to_vector()
    workplace_size_list[[i]] <- length(workplace_index_list[[i]])
  }

  ##### SCHOOLS #####
  # Calculate the number of schools:
  num_schools <- max(as.numeric(variables_list$school$get_categories()))

  # Retrieve and store the indices of individuals in the i-th household
  school_bitset_list <- vector(mode = "list", length = num_schools)
  school_index_list <- vector(mode = "list", length = num_schools)
  school_size_list <- vector(mode = "list", length = num_schools)
  for (i in seq(num_schools)) {
    school_bitset_list[[i]] <- variables_list$school$get_index_of(as.character(i))
    school_index_list[[i]] <- school_bitset_list[[i]]$to_vector()
    school_size_list[[i]] <- length(school_index_list[[i]])
  }

  ## Process Function
  function(t) {

    ## Timestep printing
    print(t)

    ## Bitset for all infectious individuals
    I <- variables_list$disease_state$get_index_of("I")

    #=== Household FOI ===#
    #=====================#
    # Open vector to store household FOIs experienced by each individual
    household_FOI <- vector(mode = "numeric", length = parameters_list$human_population)

    # Calculate the household FOI for each individual (if HH size = 1, FOI = 0)
    for (i in seq(num_households)) {

      # Retrieve the bitset of individuals in the i-th household
      spec_household <- household_bitset_list[[i]]

      # Retrieve the bitset of all infectious individuals in the i-th household
      spec_household_I <- I$copy()$and(spec_household)

      #  Calculate the FOI for the i-th household - with and without farUVC installed
      if (parameters_list$far_uvc_household) {
        if ((parameters_list$uvc_household[i] == 1) & (t > parameters_list$far_uvc_household_timestep)) {
          spec_household_FOI <- (1 - parameters_list$far_uvc_household_efficacy) * (parameters_list$beta_household * spec_household_I$size() / household_size_list[[i]]) ## this calculation needs more in it
        } else {
          spec_household_FOI <- parameters_list$beta_household * spec_household_I$size() / household_size_list[[i]] ## this calculation needs more in it
        }
      } else {
        spec_household_FOI <- parameters_list$beta_household * spec_household_I$size() / household_size_list[[i]] ## this calculation needs more in it
      }

      # Assign the i-th households FOI to the indices of the individuals residing in that household
      household_FOI[household_index_list[[i]]] <- spec_household_FOI
    }

    #=== Workplace FOI ===#
    #=====================#

    # Open an empty vector for the workplace FOI for each individual:
    workplace_FOI <- vector(mode = "numeric", length = parameters_list$human_population)

    # For each workplace:
    for (i in seq(num_workplaces)) {

      # Get the indices of individuals that work in the i-th workplace:
      spec_workplace <- workplace_bitset_list[[i]]

      # Get the indices of infectious individuals in the i-th workplace:
      spec_workplace_I <- I$copy()$and(spec_workplace)

      # Calculate the workplace-specific FOI of the i-th workplace - with and without farUVC installed
      if (parameters_list$far_uvc_workplace) {
        if ((parameters_list$uvc_workplace[i] == 1) & (t > parameters_list$far_uvc_workplace_timestep)) {
          spec_workplace_FOI <- (1 - parameters_list$far_uvc_workplace_efficacy) * (parameters_list$beta_workplace * spec_workplace_I$size() / workplace_size_list[[i]]) ## this calculation needs more in it
        } else {
          spec_workplace_FOI <- parameters_list$beta_workplace * spec_workplace_I$size() / workplace_size_list[[i]] ## this calculation needs more in it
        }
      } else {
        spec_workplace_FOI <- parameters_list$beta_workplace * spec_workplace_I$size() / workplace_size_list[[i]] ## this calculation needs more in it
      }

      # Store the workplace-specific FOR in the indices of all individuals that work there:
      workplace_FOI[workplace_index_list[[i]]] <- spec_workplace_FOI
    }

    #=== School FOI ===#
    #==================#

    # Open empty vector to store each individuals school-specific FOI:
    school_FOI <- vector(mode = "numeric", length = parameters_list$human_population)

    # For each school:
    for (i in seq(num_schools)) {

      # Retrieve the indices of children in the i-th school
      spec_school <- school_bitset_list[[i]]

      # Retrieve the indices of all infectious individuals in the i-th school:
      spec_school_I <- I$copy()$and(spec_school)

      # Calculate the school-specific FOI for the i-th school - with and without farUVC installed
      if (parameters_list$far_uvc_school) {
        if ((parameters_list$uvc_school[i] == 1) & (t > parameters_list$far_uvc_school_timestep)) {
          spec_school_FOI <- (1 - parameters_list$far_uvc_school_efficacy) * (parameters_list$beta_school * spec_school_I$size() / school_size_list[[i]]) ## this calculation needs more in it
        } else {
          spec_school_FOI <- parameters_list$beta_school * spec_school_I$size() / school_size_list[[i]] ## this calculation needs more in it
        }
      } else {
        spec_school_FOI <- parameters_list$beta_school * spec_school_I$size() / school_size_list[[i]] ## this calculation needs more in it
      }

      # Store the school-specific FOI at the indices of all children that attend it:
      school_FOI[school_index_list[[i]]] <- spec_school_FOI
    }

    #=== Leisure FOI ===#
    #=====================#

    if ((t * parameters_list$dt) == floor((t * parameters_list$dt))) {

      # Creating vector to store which leisure setting individuals visit on a given timestep (NOTE we need to change this so that it's day)
      leisure_visit <- vector(mode = "numeric", length = parameters_list$human_population)

      # For each individual, work out which leisure setting they go to that particular night - 0 = they don't go to any
      for (i in seq(parameters_list$human_population)) {

        # Which leisure settings do individuals have associated with them (and could visit)
        potential_leisure_visits <- variables_list$leisure$get_values(i)

        # Sampling wich leisure setting actually visited (0 = visit none and staying home)
        leisure_visit[i] <- sample(x = unlist(potential_leisure_visits), size = 1)
      }

      # Updating the leisure setting visited that day
      # variables_list$specific_leisure$queue_update(value = as.character(leisure_visit),
      #                                              index = as.integer(1:parameters_list$human_population))
      all_leisure_settings <- variables_list$specific_leisure$get_categories()
      variables_list$specific_leisure$initialize(categories = as.character(all_leisure_settings),
                                                 initial_values = as.character(leisure_visit)) #  update the states with leisure_visit for that day
    }

    # Open empty vector to store each individuals leisure-specific FOI:
    leisure_FOI <- vector(mode = "numeric", length = parameters_list$human_population)

    # Calculating leisure-specific FOI for each individual
    leisure_settings_visited <-  variables_list$specific_leisure$get_categories()
    leisure_settings_visited <- leisure_settings_visited[-1] # removing the "0" category which is not visited
    for (i in 1:length(leisure_settings_visited)) {

      # Access the index of the specific leisure setting being considered
      spec_leisure_setting <- as.numeric(leisure_settings_visited[i])

      # Only going through below steps if leisure setting actually visited (i.e. != 0)
      if (spec_leisure_setting != 0) {

        # Retrieve the indices of individuals visiting the specific leisure setting
        spec_leisure <- variables_list$specific_leisure$get_index_of(as.character(spec_leisure_setting))

        # Retrieve the indices of all infectious individuals in the particular leisure setting being considered
        spec_leisure_I <- I$copy()$and(spec_leisure)

        # Calculate the leisure-specific FOI for the i-th leisure setting - with and without farUVC installed
        if (parameters_list$far_uvc_leisure) {
          if ((parameters_list$uvc_leisure[i] == 1) & (t > parameters_list$far_uvc_leisure_timestep)) {
            spec_leisure_FOI <- (1 - parameters_list$far_uvc_leisure_efficacy) * (parameters_list$beta_leisure * spec_leisure_I$size() / spec_leisure$size()) ## this calculation needs more in it
          } else {
            spec_leisure_FOI <- parameters_list$beta_leisure * spec_leisure_I$size() / spec_leisure$size() ## this calculation needs more in it
          }
        } else {
          spec_leisure_FOI <- parameters_list$beta_leisure * spec_leisure_I$size() / spec_leisure$size() ## this calculation needs more in it
        }

        # Store the leisure setting-specific FOI at the indices of all individuals that attend it:
        leisure_FOI[spec_leisure$to_vector()] <- spec_leisure_FOI
      }

    }

    #=== Community FOI ===#
    #=====================#
    ### Calculate Community FOI (real-valued for all individuals)
    #### NOTE: Double check whether the "/N" is correct here - not sure currently
    community_FOI <- parameters_list$beta_community * variables_list$disease_state$get_size_of("I") / parameters_list$human_population

    #=== Total FOI ===#
    #=================#

    # Sum the household, workplace, school leisure, and community FOIs to get the total FOI for each
    # individual:
    total_FOI <- household_FOI + workplace_FOI + school_FOI + leisure_FOI + community_FOI
    print(c(max(household_FOI), max(workplace_FOI), max(school_FOI), max(leisure_FOI), max(community_FOI)))

    # Calculate the probability of getting infected in the current interval for each individual:
    p_inf <- 1 - exp(-total_FOI * parameters_list$dt)

    # Get the indices of all susceptible individuals in the current timestep:
    S <- variables_list$disease_state$get_index_of("S")

    # Get the infection probability for each currently susceptible individual:
    p_inf_currently_S <- p_inf[S$to_vector()]

    # Sample susceptible individuals using their infection probability to determine who gets infected:
    S$sample(rate = p_inf_currently_S)

    # Queue an update to the infectious state of the newly infected susceptible individuals to Exposed:
    variables_list$disease_state$queue_update(value = "E",index = S)

  }
}


#' Create the process governing the transition of exposed individuals to the infectious disease state:
#'
#' @param variables_list A list of model variables as generated by `create_variables`
#' @param events_list list of the model events as generated by `create_events`
#' @param parameters_list A list of model parameters as generated by `get_parameters`
#'
#' @export
create_EI_process <- function(variables_list, events_list, parameters_list){

  function(t) {

    # Get the indices of all exposed individuals:
    E <- variables_list$disease_state$get_index_of("E")

    # Get the indices of exposed individuals for which transitions to I have been scheduled:
    EI_already_scheduled <- events_list$EI_event$get_scheduled()

    # Get the indices of all exposed individuals with progression to I already scheduled:
    E$and(EI_already_scheduled$not(inplace = TRUE))

    # Calculate the delay until each exposed individual without a delay transitions to infected:
    I_times <- round((rgamma(E$size(), 2 * parameters_list$duration_exposed, 2) + 1) / parameters_list$dt)

    # Schedule the new transitions from exposed to infected:
    events_list$EI_event$schedule(target = E, delay = I_times)

  }
}

#' Create the process governing the transition of infectious individuals to recovered disease state:
#'
#' @param variables_list A list of model variables as generated by `create_variables`
#' @param events_list list of the model events as generated by `create_events`
#' @param parameters_list A list of model parameters as generated by `get_parameters`
#'
#' @export
create_IR_process <- function(variables_list, events_list, parameters_list) {

  function(t){

    # Get the indices of currently infectious individuals:
    I <- variables_list$disease_state$get_index_of("I")

    # Get the indices of individuals with I to R transitions already scheduled:
    IR_already_scheduled <- events_list$IR_event$get_scheduled()

    # Get the indices of infectious individuals without I to R transitions already scheduled:
    I$and(IR_already_scheduled$not(inplace = TRUE))

    # Calculate recovery times for infectious individuals without transitions scheduled:
    R_times <- round((rgamma(I$size(), 2 * parameters_list$duration_infectious, 2) + 1) / parameters_list$dt)

    # Schedule the recovery events for infectious individuals without transitions scheduled:
    events_list$IR_event$schedule(target = I, delay = R_times)

  }
}

#' Create the process governing the transition of recovered (and immune) individuals back to susceptible state:
#'
#' @param variables_list A list of model variables as generated by `create_variables`
#' @param events_list list of the model events as generated by `create_events`
#' @param parameters_list A list of model parameters as generated by `get_parameters`
#'
#' @export
create_RS_process <- function(variables_list, events_list, parameters_list) {

  function(t){

    # Get the indices of currently recovered and immune individuals:
    R <- variables_list$disease_state$get_index_of("R")

    # Get the indices of individuals with I to R transitions already scheduled:
    RS_already_scheduled <- events_list$RS_event$get_scheduled()

    # Get the indices of infectious individuals without I to R transitions already scheduled:
    R$and(RS_already_scheduled$not(inplace = TRUE))

    # Calculate recovery times for infectious individuals without transitions scheduled:
    S_times <- round((rgamma(R$size(), 2 * parameters_list$duration_immune, 2) + 1) / parameters_list$dt)

    # Schedule the recovery events for infectious individuals without transitions scheduled:
    events_list$RS_event$schedule(target = R, delay = S_times)

  }
}
