#' Define and create the model processes
#'
#' @param parameters A list of model parameters as generated by `get_parameters`
#' @param variables A list of model variables as generated by `create_variables`
#' @param events list of the model events as generated by `create_events`
#'
#' @export
create_processes <- function(
    parameters,
    variables,
    events) {

  # Open a list of processes to store the model processes in:
  processes <- list(

    # ===============================
    # Disease State Progression
    # ===============================
    # SE_process = create_SE_process(variables = variables,
    #                                events = events,
    #                                parameters = parameters),
    #### STOP! I'VE HAD TO CHANGE ROUND THE ARGUMENT INPUTS BECAUSE
    #### SOMETHING ISN'T WORKING - DO NOT MERGE UNTIL THIS IS SORTED
    SE_process = create_SE_process(variables = parameters,
                                   events = variables,
                                   parameters = events),

    # EI_process = create_EI_process(variables = variables,
    #                                events = events,
    #                                parameters = parameters),
    #### STOP! I'VE HAD TO CHANGE ROUND THE ARGUMENT INPUTS BECAUSE
    #### SOMETHING ISN'T WORKING - DO NOT MERGE UNTIL THIS IS SORTED
    EI_process = create_EI_process(variables = parameters,
                                   events = variables,
                                   parameters = events),

    # IR_process = create_IR_process(variables = variables,
    #                                events = events,
    #                                parameters = parameters)
    #### STOP! I'VE HAD TO CHANGE ROUND THE ARGUMENT INPUTS BECAUSE
    #### SOMETHING ISN'T WORKING - DO NOT MERGE UNTIL THIS IS SORTED
    IR_process = create_IR_process(variables = parameters,
                                   events = variables,
                                   parameters = events)

    # ===============================
    # Intervention processes
    # ===============================


    # ===============================
    # Rendering processes
    # ===============================
    # health_render_process

  )

  # Return the model processes:
  return(processes)

}

#' Create the process governing the transition of susceptible individuals to the exposed disease state:
#'
#' @param parameters A list of model parameters as generated by `get_parameters`
#' @param variables A list of model variables as generated by `create_variables`
#'
#' @export
create_SE_process <- function(variables, events, parameters){

  function(t) {

    print(t)
    print(t * parameters$dt)
    print("VARIABLES")
    print(variables)
    # print("EVENTS")
    # print(events[[1]])
    # print("PARAMETERS")
    # print(parameters[[1]])
    # Retrieve the indices of Infected individuals:
    I <- variables$disease_state$get_index_of("I")

    #=== Household FOI ===#
    #=====================#
    # Open vector to store household FOIs experienced by each individual
    household_FOI <- vector(mode = "numeric", length = parameters$human_population)

    # Store the number of households:
    num_households <- max(as.numeric(variables$household$get_categories()))

    # Calculate the household FOI for each individual (if HH size = 1, FOI = 0)
    for (i in seq(num_households)) {

      # Retrieve the indices of individuals in the i-th household
      spec_household <- variables$household$get_index_of(as.character(i))

      # Retrieve the indices of all infectious individuals in the i-th household
      spec_household_I <- I$and(spec_household)

      #  Calculate the FOI for the i-th household
      spec_household_FOI <- parameters$beta_household * spec_household_I$size() / spec_household$size() ## this calculation needs more in it

      # Assign the i-th households FOI to the indices of the individuals residing in that household
      household_FOI[spec_household$to_vector()] <- spec_household_FOI
    }

    #=== Workplace FOI ===#
    #=====================#

    # Open an empty vector for the workplace FOI for each individual:
    workplace_FOI <- vector(mode = "numeric", length = parameters$human_population)

    # Store the number of households:
    num_workplaces <- max(as.numeric(variables$workplace$get_categories()))

    # Get the indices of all individuals with a workplace (0's have no workplace):
    workplace_adults_only_var <- variables$workplace$get_index_of(as.character(1:max(num_workplaces)))
    ## I think we can make this more efficient if we use workplace_adults_only_var below

    # For each workplace:
    for (i in seq(num_workplaces)) {

      # Get the indices of individuals that work in the i-th workplace:
      spec_workplace <- variables$workplace$get_index_of(as.character(i))

      # Get the indices of infectious individuals in the i-th workplace:
      spec_workplace_I <- I$and(spec_workplace)

      # Calculate the workplace-specific FOI of the i-th workplace:
      spec_workplace_FOI <- parameters$beta_workplace * spec_workplace_I$size() / spec_workplace$size() ## this calculation needs more in it

      # Store the workplace-specific FOR in the indices of all individuals that work there:
      workplace_FOI[spec_workplace$to_vector()] <- spec_workplace_FOI
    }

    #=== School FOI ===#
    #==================#

    # Open empty vector to store each individuals school-specific FOI:
    school_FOI <- vector(mode = "numeric", length = parameters$human_population)

    # Get the number of schools:
    num_schools <- max(as.numeric(variables$school$get_categories()))

    # Retrieve the index of all individuals with a school (0's have no school):
    school_child_only_var <- variables$school$get_index_of(as.character(1:max(num_schools)))
    ## I think we can make this more efficient if we use school_child_only_var below

    # For each school:
    for (i in seq(num_schools)) {

      # Retrieve the indices of children in the i-th school
      spec_school <- variables$school$get_index_of(as.character(i))

      # Retrieve the indices of all infectious individuals in the i-th school:
      spec_school_I <- I$and(spec_school)

      # Calculate the school-specific FOI for the i-th school:
      spec_school_FOI <- parameters$beta_school * spec_school_I$size() / spec_school$size() ## this calculation needs more in it

      # Store the school-specific FOI at the indices of all children that attend it:
      school_FOI[spec_school$to_vector()] <- spec_school_FOI
    }

    #=== Leisure FOI ===#
    #=====================#
    ## IMPORTANT NOTE:
    ## I think we can also possibly save computational cost generally by only doing all of the FOI calculations
    ## for individuals who are susceptible. Unclear how much of a speed boost that will bring us.
    ## Also - do we need to take into account fact some people might visit different times of the day? Leave this for now.

    ## Only updating this on whole numbered timesteps (start of a new day)
    # if (t == 1) {
    #   leisure_settings_visited <- 0
    #   leisure_visit <- rep(0, parameters$human_population)
    # }
    if ((t * parameters$dt) == floor((t * parameters$dt))) {

      # Creating vector to store which leisure setting individuals visit on a given timestep (NOTE we need to change this so that it's day)
      leisure_visit <- vector(mode = "numeric", length = parameters$human_population)

      # For each individual, work out which leisure setting they go to that particular night - 0 = they don't go to any
      for (i in seq(parameters$human_population)) {

        # Which leisure settings do individuals have associated with them (and could visit)
        potential_leisure_visits <- variables$leisure$get_values(i)

        # Sampling wich leisure setting actually visited (0 = visit none and staying home)
        leisure_visit[i] <- sample(x = unlist(potential_leisure_visits), size = 1)
      }

      # Get all unique leisure settings actually visited in this timestep (NOTE: we need to change this to day)
      leisure_settings_visited <- unique(leisure_visit)

      # Update (strictly we're using "initialise" to reinitialise the variable each time, ask Giovanni if easier way of doing this)
      # the temporary leisure variable to contain the leisure settings visited in that day
      all_leisure_settings <- variables$specific_leisure$get_categories()
      variables$specific_leisure$initialize(categories = as.character(all_leisure_settings),
                                            initial_values = as.character(leisure_visit)) #  update the states with leisure_visit for that day
    }

    # Open empty vector to store each individuals leisure-specific FOI:
    leisure_FOI <- vector(mode = "numeric", length = parameters$human_population)

    # Calculating leisure-specific FOI for each individual
    leisure_settings_visited <-  variables$specific_leisure$get_categories()
    for (i in 1:length(leisure_settings_visited)) {

      # Access the index of the specific leisure setting being considered
      spec_leisure_setting <- leisure_settings_visited[i]

      # Only going through below steps if leisure setting actually visited (i.e. != 0)
      if (spec_leisure_setting != 0) {

        # Retrieve the indices of individuals visiting the specific leisure setting
        spec_leisure <- variables$specific_leisure$get_index_of(as.character(spec_leisure_setting))

        # Retrieve the indices of all infectious individuals in the particular leisure setting being considered
        spec_leisure_I <- I$and(spec_leisure)

        # Calculate the school-specific FOI for the i-th leisure setting:
        spec_leisure_FOI <- parameters$beta_leisure * spec_leisure_I$size() / spec_leisure$size() ## this calculation needs more in it

        # Store the leisure setting-specific FOI at the indices of all individuals that attend it:
        leisure_FOI[spec_leisure$to_vector()] <- spec_leisure_FOI
      }

    }

    #=== Community FOI ===#
    #=====================#
    ### Calculate Community FOI (real-valued for all individuals)
    #### NOTE: Double check whether the "/N" is correct here - not sure currently
    community_FOI <- parameters$beta_community * variables$disease_state$get_size_of("I") / parameters$human_population

    #=== Total FOI ===#
    #=================#

    # Sum the household, workplace, school leisure, and community FOIs to get the total FOI for each
    # individual:
    total_FOI <- household_FOI + workplace_FOI + school_FOI + leisure_FOI + community_FOI

    # Calculate the probability of getting infected in the current interval for each individual:
    p_inf <- 1 - exp(-total_FOI * parameters$dt)

    # Get the indices of all susceptible individuals in the current timestep:
    S <- variables$disease_state$get_index_of("S")

    # Get the infection probability for each currently susceptible individual:
    p_inf_currently_S <- p_inf[S$to_vector()]

    # Sample susceptible individuals using their infection probability to determine who gets infected:
    S$sample(rate = p_inf_currently_S)

    # Queue an update to the infectious state of the newly infected susceptible individuals to Exposed:
    variables$disease_state$queue_update(value = "E",index = S)

  }
}


#' Create the process governing the transition of exposed individuals to the infectious disease state:
#'
#' @param parameters A list of model parameters as generated by `get_parameters`
#' @param variables A list of model variables as generated by `create_variables`
#' @param events list of the model events as generated by `create_events`
#'
#' @export
create_EI_process <- function(variables, events, parameters){

  function(t) {

    # Get the indices of all exposed individuals:
    E <- variables$disease_state$get_index_of("E")

    # Get the indices of exposed individuals for which transitions to I have been scheduled:
    EI_already_scheduled <- events$EI_event$get_scheduled()

    # Get the indices of all exposed individuals with progression to I already scheduled:
    E$and(EI_already_scheduled$not(inplace = TRUE))

    # Calculate the delay until each exposed individual without a delay transitions to infected:
    I_times <- round((rgamma(E$size(), 2 * parameters$duration_exposed, 2) + 1) / parameters$dt)

    # Schedule the new transitions from exposed to infected:
    events$EI_event$schedule(target = E, delay = I_times)

  }
}

#' Create the process governing the transition of infectious individuals to recovered disease state:
#'
#' @param parameters A list of model parameters as generated by `get_parameters`
#' @param variables A list of model variables as generated by `create_variables`
#' @param events A list of model events as generated by `create_events`
#'
#' @export
create_IR_process <- function(variables, events, parameters) {

  function(t){

    # Get the indices of currently infectious individuals:
    I <- variables$disease_state$get_index_of("I")

    # Get the indices of individuals with I to R transitions already scheduled:
    IR_already_scheduled <- events$IR_event$get_scheduled()

    # Get the indices of infectious individuals without I to R transitions already scheduled:
    I$and(IR_already_scheduled$not(inplace = TRUE))

    # Calculate recovery times for infectious individuals without transitions scheduled:
    R_times <- round((rgamma(I$size(), 2 * parameters$duration_infectious, 1) + 1) / parameters$dt)

    # Schedule the recovery events for infectious individuals without transitions scheduled:
    events$IR_event$schedule(target = I, delay = R_times)

  }
}

# Define the process which renders the number of individuals in each time step:
# disease_state_count_render_process <- function(renderers, parameters, variables) {
#
#   # Create the disease state count render
#   disease_state_count_render <- Render$new(timesteps = round(parameters$simulation_time / parameters$dt))
#   disease_states <- variables$disease_state$get_categories()
#   function(t) {
#     for (i in disease_states) {
#       disease_state_count_render$render(paste0(i, '_count'), variables$disease_state$get_size_of(i), t)
#     }
#   }
# }

